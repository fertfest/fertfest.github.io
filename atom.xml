<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>fertfest的个人记录</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-21T12:37:42.086Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fertfest</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript基础学习</title>
    <link href="http://example.com/2023/09/19/TypeScript/"/>
    <id>http://example.com/2023/09/19/TypeScript/</id>
    <published>2023-09-19T15:38:26.100Z</published>
    <updated>2023-09-21T12:37:42.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><pre><code class="ts">let helloWorld = &quot;Hello World&quot;;</code></pre><p>可以推断出helloWorld的类型为string。</p><h3 id="定义类型"><a href="#定义类型" class="headerlink" title="定义类型"></a>定义类型</h3><p>自动推断：</p><pre><code class="ts">const user = &#123;  name: &quot;Hayes&quot;, // string  id: 0, // number&#125;;</code></pre><p>显式地描述上面的对象的“形状”：</p><pre><code class="ts">interface User &#123;  name: string;  id: number;&#125;</code></pre><p>声明遵循接口“形状”的对象：</p><pre><code class="ts">const user: User = &#123;  name: &quot;Hayes&quot;,  id: 0,&#125;;</code></pre><p>使用类声明接口：</p><pre><code class="ts">interface User &#123;  name: string;  id: number;&#125; class UserAccount &#123;  name: string;  id: number;   constructor(name: string, id: number) &#123;    this.name = name;    this.id = id;  &#125;&#125; const user: User = new UserAccount(&quot;Murphy&quot;, 1);</code></pre><p>使用接口注明函数参数和返回值：</p><pre><code class="ts">function deleteUser(user: User) &#123;  // ...&#125; function getAdminUser(): User &#123;  //...&#125;</code></pre><p>除了JS中的 boolean<code>, </code>bigint<code>, </code>null<code>, </code>number<code>, </code>string<code>, </code>symbol, 和 undefined类型，TS扩展了更多类型：</p><ul><li>any</li><li>unknow</li><li>never</li><li>void</li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h4><p>使用union可以声明一个类型可能是多个类型中的一个。</p><pre><code class="ts">type MyBool = true | false;type WindowStates = &quot;open&quot; | &quot;closed&quot; | &quot;minimized&quot;;type LockStates = &quot;locked&quot; | &quot;unlocked&quot;;type PositiveOddNumbersUnderTen = 1 | 3 | 5 | 7 | 9;</code></pre><p>union也提供了一种处理不同类型的方式：</p><pre><code class="ts">function getLength(obj: string | string[]) &#123;  return obj.length;&#125;</code></pre><p>使用<code>typeof</code>查询一个变量的类型:</p><table><thead><tr><th align="left">Type</th><th align="left">Predicate</th></tr></thead><tbody><tr><td align="left">string</td><td align="left"><code>typeof s === &quot;string&quot;</code></td></tr><tr><td align="left">number</td><td align="left"><code>typeof n === &quot;number&quot;</code></td></tr><tr><td align="left">boolean</td><td align="left"><code>typeof b === &quot;boolean&quot;</code></td></tr><tr><td align="left">undefined</td><td align="left"><code>typeof undefined === &quot;undefined&quot;</code></td></tr><tr><td align="left">function</td><td align="left"><code>typeof f === &quot;function&quot;</code></td></tr><tr><td align="left">array</td><td align="left"><code>Array.isArray(a)</code></td></tr></tbody></table><h4 id="泛型-Generics"><a href="#泛型-Generics" class="headerlink" title="泛型(Generics)"></a>泛型(Generics)</h4><p>不带泛型的数组可以包含任何值。带泛型的数组可以限定其元素的类型：</p><pre><code class="ts">type StringArray = Array&lt;string&gt;;type NumberArray = Array&lt;number&gt;;type ObjectWithNameArray = Array&lt;&#123; name: string &#125;&gt;;</code></pre><p>使用泛型声明自己的类型：</p><pre><code class="ts">interface Backpack&lt;Type&gt; &#123;  add: (obj: Type) =&gt; void;  get: () =&gt; Type;&#125;// 告诉TS有一个常量叫做&#39;backpack&#39;，而不关心常量从哪来declare const backpack: Backpack&lt;string&gt;;// object是一个字符串const object = backpack.get();</code></pre><h3 id="结构化类型系统"><a href="#结构化类型系统" class="headerlink" title="结构化类型系统"></a>结构化类型系统</h3><p>在一个结构化类型系统中，如果两个对象有着相同的行状态，可以说他们有相同的类型：</p><pre><code class="ts">interface Point &#123;  x: number;  y: number;&#125; function logPoint(p: Point) &#123;  console.log(`$&#123;p.x&#125;, $&#123;p.y&#125;`);&#125; // logs &quot;12, 26&quot;const point = &#123; x: 12, y: 26 &#125;;logPoint(point);</code></pre><p>形状匹配只要求对象字段被要求的部分匹配即可：</p><pre><code class="ts">const point3 = &#123; x: 12, y: 26, z: 89 &#125;;logPoint(point3); // logs &quot;12, 26&quot;  const rect = &#123; x: 33, y: 3, width: 30, height: 80 &#125;;logPoint(rect); // logs &quot;33, 3&quot; const color = &#123; hex: &quot;#187ABF&quot; &#125;;logPoint(color); // fail!!!</code></pre><p>对于类和对象如何满足形状要求没有区别：</p><pre><code class="ts">class VirtualPoint &#123;  x: number;  y: number;   constructor(x: number, y: number) &#123;    this.x = x;    this.y = y;  &#125;&#125; const newVPoint = new VirtualPoint(13, 56);logPoint(newVPoint); // logs &quot;13, 56&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;类型推断&quot;&gt;&lt;a href=&quot;#类型推断&quot; class=&quot;headerlink&quot; title=&quot;类型推断&quot;&gt;&lt;/a&gt;类型推断&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;ts&quot;&gt;let helloWorld = &amp;quot;Hello World&amp;quot;;
&lt;</summary>
      
    
    
    
    
    <category term="web开发" scheme="http://example.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
    <category term="TypeScript" scheme="http://example.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>《Full Stack Open》学习记录</title>
    <link href="http://example.com/2023/08/29/Fullstack/"/>
    <id>http://example.com/2023/08/29/Fullstack/</id>
    <published>2023-08-29T04:57:25.501Z</published>
    <updated>2023-09-11T11:23:53.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>课程网址：<a href="https://fullstackopen.com/en/">https://fullstackopen.com/en/</a></p><p>课程全称是”Deep Dive Into Modern Web Development”，即“深入现代Web开发”。</p><p>在这门课程中将会学习到React，Redux，Node.js，MongoDB, GraphQL 和 TypeScript等知识。简单来说就是专注于用ReactJS和Node.js构建单页应用。</p><h2 id="part0"><a href="#part0" class="headerlink" title="part0"></a>part0</h2><h3 id="a-通用信息"><a href="#a-通用信息" class="headerlink" title="a. 通用信息"></a>a. 通用信息</h3><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>如果没有JS经验，那么要能够非常流利地使用你自己的编程语言（大概100~200个小时的练习）。</p><h4 id="课程材料"><a href="#课程材料" class="headerlink" title="课程材料"></a>课程材料</h4><p>课程材料基于逐渐扩大的示例应用，这些应用随着课程进度增加而改变。</p><h4 id="加入课程"><a href="#加入课程" class="headerlink" title="加入课程"></a>加入课程</h4><p>课程分为14个部分，每一部分平均需要15~20小时，但是这不是一定的。</p><p>1~4部分会有标记了星号(*)的练习，这些练习会计入总分，但是不会影响你完成下一部分的练习。</p><p>5~13部分没有标记*的练习。</p><h4 id="提交练习"><a href="#提交练习" class="headerlink" title="提交练习"></a>提交练习</h4><p>练习通过GitHub提交，并且在提交系统中将练习标记为已完成。</p><p>练习提交时需要一次性提交一部分的练习。</p><h4 id="课程考试"><a href="#课程考试" class="headerlink" title="课程考试"></a>课程考试</h4><p>为了得到官方的大学学分，你需要通过涵盖课程1~5部分的课程考试。</p><h4 id="开始课程之旅前"><a href="#开始课程之旅前" class="headerlink" title="开始课程之旅前"></a>开始课程之旅前</h4><p>安装<a href="https://www.google.com/chrome/">Chrome browser</a>&#x2F; <a href="https://www.mozilla.org/en-US/firefox/developer/">Developer Edition of Firefox</a>。</p><p>学会Git和GitHub的基本操作。</p><p>安装文本编辑器，推荐<a href="https://code.visualstudio.com/">Visual Studio Code</a>。</p><p>安装 <a href="https://nodejs.org/en/">Node.js</a>，要求版本18.13.0或以上(2023&#x2F;8&#x2F;29)。</p><h3 id="b-Web应用基础"><a href="#b-Web应用基础" class="headerlink" title="b. Web应用基础"></a>b. Web应用基础</h3><p>Web开发的第一原则：在你的浏览器上确保开发者终端一直打开着。（Win11中chrome里按F12）</p><h4 id="HTTP-GET"><a href="#HTTP-GET" class="headerlink" title="HTTP GET"></a>HTTP GET</h4><p>服务器和web浏览器通过HTTP协议进行通信。</p><h4 id="传统web应用"><a href="#传统web应用" class="headerlink" title="传统web应用"></a>传统web应用</h4><p><a href="https://studies.cs.helsinki.fi/exampleapp/">示例应用</a>的主页就是以传统web应用方式工作的。当进入页面时，浏览器从服务器取回HTML文档，文档详述了页面的结构和文本内容。</p><h4 id="在浏览器中运行应用逻辑"><a href="#在浏览器中运行应用逻辑" class="headerlink" title="在浏览器中运行应用逻辑"></a>在浏览器中运行应用逻辑</h4><p>打开网址<a href="https://studies.cs.helsinki.fi/exampleapp/data.json%E6%97%B6%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E9%9D%9E%E5%B8%B8%E6%B7%B7%E4%B9%B1%E7%9A%84json%E6%95%B0%E6%8D%AE%EF%BC%8Cchrome%E9%BB%98%E8%AE%A4%E4%B8%8D%E4%BC%9A%E4%BB%A5%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%BE%E5%BC%8Fjson%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%86%E6%98%AF%E5%8F%AF%E4%BB%A5%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E6%9D%A5%E6%96%B9%E4%BE%BF%E6%88%91%E4%BB%AC%E6%9F%A5%E7%9C%8Bjson%EF%BC%9A">https://studies.cs.helsinki.fi/exampleapp/data.json时我们可以看到非常混乱的json数据，chrome默认不会以结构化的方式显式json数据，但是可以安装插件来方便我们查看json：</a></p><p><a href="https://chrome.google.com/webstore/detail/jsonview/chklaanhfefbnpoihckbnefhakgolnmc">JSONVue</a></p><h4 id="事件处理器和回调函数"><a href="#事件处理器和回调函数" class="headerlink" title="事件处理器和回调函数"></a>事件处理器和回调函数</h4><p>事件处理器函数被叫做回调函数。应用程序代码不会调用这些函数，但是当事件发生时运行时环境-浏览器会在合适的时间调用这些函数。</p><h4 id="文档对象模型-x2F-DOM"><a href="#文档对象模型-x2F-DOM" class="headerlink" title="文档对象模型&#x2F;DOM"></a>文档对象模型&#x2F;DOM</h4><p>我们可以把HTML页面当做隐式的树形结构：</p><pre><code class="html">html  head    link    script  body    div      h1      div        ul          li          li          li      form        input        input</code></pre><p>浏览器基于这一观点将HTML元素们描绘成一棵树:</p><img src="..\images\Fullstack\part0\文档对象模型.png"/><p>文档对象模型是一个应用程序编程接口(API)，使得元素树的编程式的改变可以映射到web页面。例如：</p><pre><code class="js">//创建新节点并赋值给变量ul，然后给它添加一些孩子结点var ul = document.createElement(&#39;ul&#39;)data.forEach(function(note) &#123;  var li = document.createElement(&#39;li&#39;)  ul.appendChild(li)  li.appendChild(document.createTextNode(note.content))&#125;)</code></pre><h4 id="用终端操作文档对象"><a href="#用终端操作文档对象" class="headerlink" title="用终端操作文档对象"></a>用终端操作文档对象</h4><p>DOM树最顶级的结点叫做<code>document</code>对象。在终端选项卡中键入”document”可以访问<code>document</code>对象：</p><p><img src="C:\Users\chen2\Desktop\files\cyccycyy.github.io\source\images\Fullstack\part0\终端访问文档对象.png"></p><p>甚至可以添加文档对象到页面中：</p><p><img src="C:\Users\chen2\Desktop\files\cyccycyy.github.io\source\images\Fullstack\part0\通过终端添加文档对象到页面中.png"></p><p>可以看到我们通过终端向ul添加了一个li标签。</p><h2 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h2><h3 id="a-React入门"><a href="#a-React入门" class="headerlink" title="a. React入门"></a>a. React入门</h3><p>现在开始构建React最简单的方式是使用<a href="https://vitejs.dev/">Vite</a>。</p><p>创建一个叫part1的应用，进入到它的目录并且安装库：</p><pre><code class="shell">npm create vite@latest part1 -- --template reactcd part1npm install</code></pre><p>开始应用：</p><pre><code class="shell">npm run dev</code></pre><p>文件瘦身：</p><pre><code class="jsx">//main.jsximport ReactDOM from &#39;react-dom/client&#39;import App from &#39;./App&#39;ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App /&gt;)</code></pre><pre><code class="jsx">//App.jsxconst App = () =&gt; (  &lt;div&gt;    &lt;p&gt;Hello world&lt;/p&gt;  &lt;/div&gt;)export default App</code></pre><h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><p><strong>注意组件名首字母必须大写！！！</strong></p><p>main.jsx的最后一行:</p><pre><code class="jsx">ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App /&gt;)</code></pre><p>把组件App的内容渲染到了root中。</p><p>在React中，所有需要被渲染的内容通常都定义成React组件(虽然写在index.html中的内容也会被渲染)。</p><pre><code class="jsx">//App.jsxconst App = () =&gt; (  &lt;div&gt;    &lt;p&gt;Hello world&lt;/p&gt;  &lt;/div&gt;)export default App</code></pre><p>上面的代码定义了一个组件App，有几点值得注意：</p><ul><li><p>组件被定义成一个JS函数。函数被赋给变量App。</p></li><li><p>JS有几种定义函数的方式，但是这里使用的是箭头函数。</p></li><li><p>因为函数只由一个表达式组成，所以我们使用了缩写(shorthand)。如果不使用缩写函数将是这样：</p><pre><code class="jsx">const App = () =&gt; &#123;  return (    &lt;div&gt;      &lt;p&gt;Hello world&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre></li></ul><p>组件内容动态渲染：</p><pre><code class="jsx">const App = () =&gt; &#123;  const now = new Date()  const a = 10  const b = 20  console.log(now, a+b)  return (    &lt;div&gt;      &lt;p&gt;Hello world, it is &#123;now.toString()&#125;&lt;/p&gt;      &lt;p&gt;        &#123;a&#125; plus &#123;b&#125; is &#123;a + b&#125;      &lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><p>虽然JSX看起来像HTML，但是我们所做的其实是一种写JS的方式。React组件返回的JSX被编译成JavaScript。在编译后，App.jsx看起来像这样：</p><pre><code class="js">const App = () =&gt; &#123;  const now = new Date()  const a = 10  const b = 20  return React.createElement(    &#39;div&#39;,    null,    React.createElement(      &#39;p&#39;, null, &#39;Hello world, it is &#39;, now.toString()    ),    React.createElement(      &#39;p&#39;, null, a, &#39; plus &#39;, b, &#39; is &#39;, a + b    )  )&#125;</code></pre><p>编译工作由<a href="https://babeljs.io/repl/">Babel</a>处理。</p><p>JSX是一种“类XML”语法，这意味着每一个tag都需要被关闭。例如在JSX中不能这样写换行tag：</p><pre><code class="jsx">&lt;br&gt;</code></pre><p>而必须这样写：</p><pre><code class="jsx">&lt;br /&gt;</code></pre><h4 id="多组件"><a href="#多组件" class="headerlink" title="多组件"></a>多组件</h4><p>定义Hello组件：</p><pre><code class="jsx">const Hello = () =&gt; &#123;  return (    &lt;div&gt;      &lt;p&gt;Hello world&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>将App.jsx改成下面这样：</p><pre><code class="jsx">const App = () =&gt; &#123;  return (    &lt;div&gt;      &lt;h1&gt;Greetings&lt;/h1&gt;      &lt;Hello /&gt;    &lt;/div&gt;  )&#125;</code></pre><p>这表示在App中使用Hello组件，当然可以不止一次地使用Hello：</p><pre><code class="jsx">const App = () =&gt; &#123;  return (    &lt;div&gt;      &lt;h1&gt;Greetings&lt;/h1&gt;      &lt;Hello /&gt;      &lt;Hello /&gt;      &lt;Hello /&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="props-传递数据给组件"><a href="#props-传递数据给组件" class="headerlink" title="props: 传递数据给组件"></a>props: 传递数据给组件</h4><p>修改Hello组件：</p><pre><code class="jsx">const Hello = (props) =&gt; &#123;  return (    &lt;div&gt;      &lt;p&gt;Hello &#123;props.name&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>注意函数定义有了一个props形参用于接收Hello组件用户传入的”props”。</p><p>props像这样定义：</p><pre><code class="jsx">const App = () =&gt; &#123;  return (    &lt;div&gt;      &lt;h1&gt;Greetings&lt;/h1&gt;      &lt;Hello name=&#39;George&#39; /&gt;       &lt;Hello name=&#39;Daisy&#39; /&gt;       &#123;          //here!       &#125;    &lt;/div&gt;  )&#125;</code></pre><h4 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h4><p>注意一个React组件的内容通常需要包含一个根元素，例如：</p><pre><code class="js">const App = () =&gt; &#123;  return (    &lt;h1&gt;Greetings&lt;/h1&gt;    &lt;Hello name=&#39;Maya&#39; age=&#123;26 + 10&#125; /&gt;    &lt;Footer /&gt;  )&#125;</code></pre><p>Vite会报错：</p><p><img src="/..%5Cimages%5CFullstack%5Cpart1%5C%E7%BB%84%E4%BB%B6%E6%B2%A1%E6%9C%89%E6%A0%B9%E5%85%83%E7%B4%A0%E6%8A%A5%E9%94%99.png" alt="组件没有根元素报错"></p><p>使用根元素不是唯一的工作选择，组件数组也是有效的解决方案：</p><pre><code class="jsx">const App = () =&gt; &#123;  return [    &lt;h1&gt;Greetings&lt;/h1&gt;,    &lt;Hello name=&#39;Maya&#39; age=&#123;26 + 10&#125; /&gt;,    &lt;Footer /&gt;  ]&#125;</code></pre><p>根元素是被强制要求的，这样(指用div元素包裹的方式)在DOM树中会有一个“额外”的div元素。可以通过<a href="https://react.dev/reference/react/Fragment">fragments</a>避免：</p><pre><code class="jsx">const App = () =&gt; &#123;  const name = &#39;Peter&#39;  const age = 10  return (      &#123;          //fragments 就是空的标签对      &#125;    &lt;&gt;      &lt;h1&gt;Greetings&lt;/h1&gt;      &lt;Hello name=&#39;Maya&#39; age=&#123;26 + 10&#125; /&gt;      &lt;Hello name=&#123;name&#125; age=&#123;age&#125; /&gt;      &lt;Footer /&gt;    &lt;/&gt;  )&#125;</code></pre><h4 id="不要渲染对象"><a href="#不要渲染对象" class="headerlink" title="不要渲染对象"></a>不要渲染对象</h4><p>对象作为React child不会生效，即应用尝试渲染对象但是失败了。</p><p>可以直接渲染数组，只要数组的元素是可以渲染的。但是这样的结果应该并不是你想要的：</p><pre><code class="jsx">const App = () =&gt; &#123;  const friends = [ &#39;Peter&#39;, &#39;Maya&#39;]  return (    &lt;div&gt;      &lt;p&gt;&#123;friends&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><h3 id="b-JavaScript"><a href="#b-JavaScript" class="headerlink" title="b. JavaScript"></a>b. JavaScript</h3><p>JavaScript标准的官方名称叫<a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a>。截止2023年6月份，最新版本是<a href="https://www.ecma-international.org/ecma-262/">ECMAScript®2023</a>，也称为ES14。</p><p>浏览器还不支持所有JS的新特性，由于这一原因，许多运行在浏览器中的代码都被从更新版本的JS转译到旧的、更兼容的版本。现如今最受欢迎的转译方式是使用<a href="https://babeljs.io/">Babel</a>。</p><p><a href="https://nodejs.org/en/">Node.js</a>是基于谷歌<a href="https://developers.google.com/v8/">Chrome V8</a> JS引擎的JS运行环境，最新版的Node已经能理解最新版的JS，所以写给Node的代码不需要转译。</p><p>由于之前学过JS语法，这里就简单记录一下一些要点：</p><ul><li><p>不建议使用var，因为var的机制(如作用域)很奇怪。使用ES6引入的let和const。</p></li><li><p>函数式编程范式的一个性质是不可变(immutable)数据结构的使用。在React代码中，最好使用concat而不是push。</p><pre><code class="javascript">const t = [1, -1, 3]const t2 = t.concat(5)  // creates new arrayconsole.log(t)  // [1, -1, 3] is printedconsole.log(t2) // [1, -1, 3, 5] is printed</code></pre></li><li><p>解构赋值：</p><pre><code class="javascript">const t = [1, 2, 3, 4, 5]//注意const会让first，second和rest都不可变。const [first, second, ...rest] = tconsole.log(first, second)  // 1, 2 is printedconsole.log(rest)          // [3, 4, 5] is printed</code></pre></li><li><p>箭头函数如果只有一个参数，可以省略包裹参数的括号，如果函数内只有一条语句并且是返回语句，可以省略函数体括号和return：</p><pre><code class="js">const square = p =&gt; p * p</code></pre><p>箭头函数在ES6被加入JS中，在此之前定义函数只能使用<em>function</em>关键字。</p></li><li><p>this指向问题：</p><pre><code class="js">const arto = &#123;  name: &#39;Arto Hellas&#39;,  age: 35,  education: &#39;PhD&#39;,  greet: function() &#123;    console.log(&#39;hello, my name is &#39; + this.name)  &#125;,  doAddition: function(a, b) &#123;    console.log(a + b)  &#125;,&#125;arto.doAddition(1, 4)        // 5 is printedconst referenceToAddition = arto.doAdditionreferenceToAddition(10, 15)   // 25 is printed</code></pre><p>doAddition函数没有使用this，可以良好地工作。但是如果以类似地方式测试greet函数：</p><pre><code class="js">arto.greet()       // hello, my name is Arto Hellas const referenceToGreet = arto.greetreferenceToGreet() // hello, my name is//不会打印arto.name</code></pre><p>与其它语言不同，JS中<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">this</a>值的定义是基于<strong>方法被调用的方式</strong>的。当通过引用调用方法时，<em>this</em>值变成了所谓的全局对象(<a href="https://developer.mozilla.org/en-US/docs/Glossary/Global_object">global object</a>)：</p><pre><code class="js">let name = &quot;xiao ming&quot;referenceToGreet() //hello, my name is xiao ming</code></pre><p>在使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">setTimeout</a>函数时也会出现同样的问题：</p><pre><code class="js">const arto = &#123;  name: &#39;Arto Hellas&#39;,  greet: function() &#123;    console.log(&#39;hello, my name is &#39; + this.name)  &#125;,&#125;setTimeout(arto.greet, 1000)</code></pre><p>因为事实上是JS引擎调用greet方法，在这种情况下this指向全局对象。</p><p>可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">bind</a>来解决这类问题：</p><pre><code class="js">setTimeout(arto.greet.bind(arto), 1000)</code></pre><p>然而在这门课中我们通过使用”减少this使用的(this-less)”JavaScript来避免这样的问题。</p></li></ul><h3 id="c-组件状态，事件处理器"><a href="#c-组件状态，事件处理器" class="headerlink" title="c. 组件状态，事件处理器"></a>c. 组件状态，事件处理器</h3><h4 id="组件辅助函数"><a href="#组件辅助函数" class="headerlink" title="组件辅助函数"></a>组件辅助函数</h4><pre><code class="js">const Hello = (props) =&gt; &#123;  const bornYear = () =&gt; &#123;    const yearNow = new Date().getFullYear()    return yearNow - props.age  &#125;  return (    &lt;div&gt;      &lt;p&gt;        Hello &#123;props.name&#125;, you are &#123;props.age&#125; years old      &lt;/p&gt;      &lt;p&gt;So you were probably born in &#123;bornYear()&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>上面的bornYear定义在Hello组件的内部，它不必声明参数就可以使用Hello的参数。当Hello组件被渲染时函数会被调用。</p><h4 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h4><p>解构使得变量的赋值更加简单，因为我们可以用它来提取并收集对象的属性，然后把这些属性赋给不同的变量：</p><pre><code class="js">const Hello = (props) =&gt; &#123;  const &#123; name, age &#125; = props // Here we are!!!  const bornYear = () =&gt; new Date().getFullYear() - age  return (    &lt;div&gt;      &lt;p&gt;Hello &#123;name&#125;, you are &#123;age&#125; years old&lt;/p&gt;      &lt;p&gt;So you were probably born in &#123;bornYear()&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><p>甚至可以更简洁地使用解构：</p><pre><code class="js">const Hello = (&#123; name, age &#125;) =&gt; &#123; // 注意参数！！！  const bornYear = () =&gt; new Date().getFullYear() - age  return (    &lt;div&gt;      &lt;p&gt;        Hello &#123;name&#125;, you are &#123;age&#125; years old      &lt;/p&gt;      &lt;p&gt;So you were probably born in &#123;bornYear()&#125;&lt;/p&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="页面重新渲染"><a href="#页面重新渲染" class="headerlink" title="页面重新渲染"></a>页面重新渲染</h4><pre><code class="jsx">//App.jsxconst App = (props) =&gt; &#123;  const &#123;counter&#125; = props  return (    &lt;div&gt;&#123;counter&#125;&lt;/div&gt;  )&#125;export default App</code></pre><pre><code class="jsx">//main.jsximport ReactDOM from &#39;react-dom/client&#39;import App from &#39;./App&#39;let counter = 1ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;App counter=&#123;counter&#125; /&gt;)</code></pre><p>上面的代码通过props将counter的值传给App，浏览器将会渲染counter的值1。</p><p>如果我们在</p><pre><code class="jsx">ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;App counter=&#123;counter&#125; /&gt;)</code></pre><p>之后让counter自增，即<code>counter+=1</code>，页面不会重新渲染，页面中还是显示1而不是2。因为这样做不会让页面重新渲染。如果要让页面重新渲染，可以使用render方法：</p><pre><code class="jsx">//main.jsxlet counter = 1const root_elem = document.getElementById(&#39;root&#39;)const root = ReactDOM.createRoot(root_elem)const refresh = () =&gt; &#123;    root.render(&lt;App counter=&#123;counter&#125; /&gt;)&#125;refresh()counter += 1refresh()counter += 1refresh()</code></pre><p>然而，重复调用render并不是一种推荐的重新渲染组件的方式。更好的方式在下面。</p><h4 id="有状态-stateful-组件"><a href="#有状态-stateful-组件" class="headerlink" title="有状态(stateful)组件"></a>有状态(stateful)组件</h4><p>下面将在React的 <a href="https://react.dev/learn/state-a-components-memory">state hook</a>的帮助下为App组件添加状态。</p><pre><code class="jsx">//App.jsximport &#123; useState &#125; from &#39;react&#39; //引入useState函数const App = () =&gt; &#123;  const [ counter, setCounter ] = useState(0) //使用useState函数为组件添加初始值为0的state  //counter变量被赋予了状态的初始值0  //setCounter则被赋予了用来修改state的函数  setTimeout(    () =&gt; setCounter(counter + 1),    1000  )  return (    &lt;div&gt;&#123;counter&#125;&lt;/div&gt;  )&#125;export default App</code></pre><p>当<em>状态修改函数</em><code>setCounter</code>被调用时，React重新渲染组件，这意味着组件函数的函数体</p><pre><code class="jsx">() =&gt; &#123;  const [ counter, setCounter ] = useState(0)  setTimeout(    () =&gt; setCounter(counter + 1),    1000  )  return (    &lt;div&gt;&#123;counter&#125;&lt;/div&gt;  )&#125;</code></pre><p>会被再次执行。</p><p>第二次组件函数执行时会调用<code>useState</code>函数，<code>useState</code><strong>函数返回state的新值：1。</strong></p><p>再次执行函数体也再一次对<code>setTimeout</code>进行了调用。</p><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><pre><code class="jsx">const App = () =&gt; &#123;  const [ counter, setCounter ] = useState(0)  return (    &lt;div&gt;      &lt;div&gt;&#123;counter&#125;&lt;/div&gt;      &lt;button onClick=&#123;() =&gt; setCounter(counter + 1)&#125;&gt;        plus      &lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setCounter(0)&#125;&gt;         zero      &lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><h4 id="一个事件处理器是一个函数"><a href="#一个事件处理器是一个函数" class="headerlink" title="一个事件处理器是一个函数"></a>一个事件处理器是一个函数</h4><pre><code class="jsx">const App = () =&gt; &#123;  const [counter, setCounter] = useState(0)  return (    &lt;div&gt;      &lt;div&gt;&#123;counter&#125;&lt;/div&gt;      &lt;button onClick=&#123;setCounter(counter + 1)&#125;&gt;&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>像上面这样{}内并不是函数定义，而是<strong>函数调用</strong>，当App第一次被渲染时，将会执行<code>setCounter(counter + 1)</code>，然后由于<code>setCounter</code>调用会让App组件重新渲染，App内的代码又会被执行，也会执行<code>setCounter(counter + 1)</code>，然后由于<code>setCounter</code>调用会让App组件重新渲染……导致了组件的无限重新渲染。但是React并不会允许太多次的重新渲染：<code>Uncaught Error: Too many re-renders. React limits the number of renders to prevent an infinite loop.</code></p><h4 id="传递状态到子组件"><a href="#传递状态到子组件" class="headerlink" title="传递状态到子组件"></a>传递状态到子组件</h4><p><strong>最佳实践</strong>：经常会出现好几个组件需要对相同的数据变动做出反应。我们推荐将共同的状态提升到他们最近的公共祖先。</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="d-更复杂的状态，调试React应用"><a href="#d-更复杂的状态，调试React应用" class="headerlink" title="d. 更复杂的状态，调试React应用"></a>d. 更复杂的状态，调试React应用</h3><h4 id="复杂状态"><a href="#复杂状态" class="headerlink" title="复杂状态"></a>复杂状态</h4><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">object spread</a>(对象传播)语法：</p><pre><code class="jsx">const handleLeftClick = () =&gt;  setClicks(&#123; ...clicks, left: clicks.left + 1 &#125;)const handleRightClick = () =&gt;  setClicks(&#123; ...clicks, right: clicks.right + 1 &#125;)</code></pre><p>将所有状态存储到单个状态对象对于我们的counter应用来说是一个不好的选择，这样做并没有明显的好处，而且代码也更复杂了。所以在这种情况下还是将状态分开存储好一些。</p><p>有些情况下存储单个状态对象有好处，详见<a href="https://react.dev/learn/choosing-the-state-structure">React官方文档</a> 。</p><h4 id="状态的更新是异步的"><a href="#状态的更新是异步的" class="headerlink" title="状态的更新是异步的"></a>状态的更新是异步的</h4><p>在React中状态的更新是异步的，当调用<code>setLeft(left)</code>时，left并不会马上更新，而是在组件重新渲染后的<strong>某个时间点</strong>更新。</p><h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><pre><code class="jsx">const History = (props) =&gt; &#123;  if (props.allClicks.length === 0) &#123;    return (      &lt;div&gt;        the app is used by pressing the buttons      &lt;/div&gt;    )  &#125;  return (    &lt;div&gt;      button press history: &#123;props.allClicks.join(&#39; &#39;)&#125;    &lt;/div&gt;  )&#125;</code></pre><p>History组件因props.allClicks.length的不同而渲染出不同的元素，这叫做条件渲染。</p><h4 id="调试React应用"><a href="#调试React应用" class="headerlink" title="调试React应用"></a>调试React应用</h4><p>console.log()调试比较简单(但是好用)。除此以外还有其它调试方式：</p><p>在你的代码中写下命令:<code>debugger</code>，Chrome会在到达该语句的时候暂停执行。</p><p>也可以在浏览器开发者工具Sources栏找到源文件，在想要的地方添加断点。</p><h4 id="钩子函数的使用准则"><a href="#钩子函数的使用准则" class="headerlink" title="钩子函数的使用准则"></a>钩子函数的使用准则</h4><ul><li><p>useState(和useEffect)函数不能在循环、条件表达式或者任何不是定义组件的函数体的地方被调用。</p><pre><code class="jsx">const App = () =&gt; &#123;  // these are ok  const [age, setAge] = useState(0)  const [name, setName] = useState(&#39;Juha Tauriainen&#39;)  if ( age &gt; 10 ) &#123;    // this does not work!    const [foobar, setFoobar] = useState(null)  &#125;  for ( let i = 0; i &lt; age; i++ ) &#123;    // also this is not good    const [rightWay, setRightWay] = useState(false)  &#125;  const notGood = () =&gt; &#123;    // and this is also illegal    const [x, setX] = useState(-1000)  &#125;  return (    //...  )&#125;</code></pre></li></ul><h4 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h4><p>另一种定义事件处理器的方式是使用返回函数的函数。</p><pre><code class="jsx">const App = () =&gt; &#123;  const [value, setValue] = useState(10)  const hello = () =&gt; &#123;    const handler = () =&gt; console.log(&#39;hello world&#39;)    return handler  &#125;  return (    &lt;div&gt;      &#123;value&#125;      &lt;button onClick=&#123;hello()&#125;&gt;button&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>以上代码当App被渲染时，函数：</p><pre><code class="jsx">const hello = () =&gt; &#123;    const handler = () =&gt; console.log(&#39;hello world&#39;)    return handler  &#125;</code></pre><p>会被执行，函数返回一个函数对象handler，然后：</p><pre><code class="jsx">&lt;button onClick=&#123;hello()&#125;&gt;button&lt;/button&gt;</code></pre><p>会使得onClick的值是一个函数。</p><p>看起来来好像并没有什么用？</p><p>更复杂的使用示例：</p><pre><code class="jsx">const App = () =&gt; &#123;  const [value, setValue] = useState(10)  const hello = (who) =&gt; &#123;    const handler = () =&gt; &#123;      console.log(&#39;hello&#39;, who)    &#125;    return handler  &#125;  return (    &lt;div&gt;      &#123;value&#125;      &lt;button onClick=&#123;hello(&#39;world&#39;)&#125;&gt;button&lt;/button&gt;      &lt;button onClick=&#123;hello(&#39;react&#39;)&#125;&gt;button&lt;/button&gt;      &lt;button onClick=&#123;hello(&#39;function&#39;)&#125;&gt;button&lt;/button&gt;    &lt;/div&gt;  )&#125;</code></pre><p>这样就会让每个button得到不同的事件处理器。</p><h4 id="不要在组件中定义组件"><a href="#不要在组件中定义组件" class="headerlink" title="不要在组件中定义组件"></a>不要在组件中定义组件</h4><p>虽然在组件中定义组件有可能也能让应用正常工作，但是这样的方式没有好处并且会导致许多问题。最大的问题是React在<strong>每一次渲染时将定义在另一个组件中的组件当成新组件</strong>。这使得React不能优化该组件。</p><h2 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h2><h3 id="a-渲染一个集合-collection-，模块-modules"><a href="#a-渲染一个集合-collection-，模块-modules" class="headerlink" title="a. 渲染一个集合(collection)，模块(modules)"></a>a. 渲染一个集合(collection)，模块(modules)</h3><h4 id="渲染集合"><a href="#渲染集合" class="headerlink" title="渲染集合"></a>渲染集合</h4><pre><code class="jsx">//App.jsxconst App = (props) =&gt; &#123;  const &#123; notes &#125; = props  return (    &lt;div&gt;      &lt;h1&gt;Notes&lt;/h1&gt;      &lt;ul&gt;        &lt;li&gt;&#123;notes[0].content&#125;&lt;/li&gt;        &lt;li&gt;&#123;notes[1].content&#125;&lt;/li&gt;        &lt;li&gt;&#123;notes[2].content&#125;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  )&#125;export default App</code></pre><pre><code class="jsx">//main.jsximport React from &#39;react&#39;import ReactDOM from &#39;react-dom/client&#39;import App from &#39;./App&#39;const notes = [  &#123;    id: 1,    content: &#39;HTML is easy&#39;,    important: true  &#125;,  &#123;    id: 2,    content: &#39;Browser can execute only JavaScript&#39;,    important: false  &#125;,  &#123;    id: 3,    content: &#39;GET and POST are the most important methods of HTTP protocol&#39;,    important: true  &#125;]ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;App notes=&#123;notes&#125; /&gt;)</code></pre><p>在上面的代码中，我们通过硬编码的方式渲染note：</p><pre><code class="jsx">&lt;li&gt;&#123;notes[1].content&#125;&lt;/li&gt;</code></pre><p>在实际开发中我们当然有更合理的方式—我们可以使用map函数来从数组对象中生成React元素：</p><pre><code class="jsx">notes.map(note =&gt; &lt;li&gt;&#123;note.content&#125;&lt;/li&gt;)</code></pre><h4 id="key属性"><a href="#key属性" class="headerlink" title="key属性"></a>key属性</h4><p>上面的程序看起来能正常工作，但是在终端里会有一个警告：</p><p><img src="/..%5Cimages%5CFullstack%5Cpart2%5C%E8%AD%A6%E5%91%8A-list%E5%85%83%E7%B4%A0%E6%B2%A1%E6%9C%89key.png" alt="警告-list元素没有key"></p><p>错误信息，同时也是React想表达的，建议我们由map方法生成的list项必须都有独特的key值：即叫做key的属性。</p><p>添加key属性：</p><pre><code class="jsx">&#123;notes.map(note =&gt;      &lt;li key=&#123;note.id&#125;&gt;        &#123;note.content&#125;     &lt;/li&gt;)&#125;</code></pre><p>React使用数组中的对象的key属性来决定当组件被重新渲染时如何更新由组件生成的视图(view)。</p><h4 id="反模式：数组索引作为key"><a href="#反模式：数组索引作为key" class="headerlink" title="反模式：数组索引作为key"></a>反模式：数组索引作为key</h4><pre><code class="jsx">&lt;ul&gt;  &#123;notes.map((note, i) =&gt;     &lt;li key=&#123;i&#125;&gt;      &#123;note.content&#125;    &lt;/li&gt;  )&#125;&lt;/ul&gt;</code></pre><p>即使这样做能够工作，并且终端也没有警告信息，但是仍然不推荐这样做。详情见<a href="https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318">这篇文章</a>。</p><h4 id="重构模块"><a href="#重构模块" class="headerlink" title="重构模块"></a>重构模块</h4><p>让我们把代码写得更简单明了一些：</p><pre><code class="jsx">const Note = (&#123; note &#125;) =&gt; &#123;  return (    &lt;li&gt;&#123;note.content&#125;&lt;/li&gt;  )&#125;const App = (&#123; notes &#125;) =&gt; &#123;  return (    &lt;div&gt;      &lt;h1&gt;Notes&lt;/h1&gt;      &lt;ul&gt;        &#123;notes.map(note =&gt;           &lt;Note key=&#123;note.id&#125; note=&#123;note&#125; /&gt;        )&#125;      &lt;/ul&gt;    &lt;/div&gt;  )&#125;</code></pre><p><strong>NB</strong> key属性必须定义在Note组件上，而不是li上！</p><p>我们使用过很多次模块了，main.jsx的前几行：</p><pre><code class="jsx">import ReactDOM from &quot;react-dom/client&quot;import App from &quot;./App&quot;</code></pre><p>引入了两个模块。</p><p>我们说：模块<em>react-dom&#x2F;client</em> <strong>被放进</strong>(placed into)变量<em>ReactDOM</em>中，定义应用的主组件的模块<strong>被放进</strong>变量App中。</p><p>模块输出：</p><pre><code class="jsx">const Note = (&#123; note &#125;) =&gt; &#123;  return (    &lt;li&gt;&#123;note.content&#125;&lt;/li&gt;  )&#125;export default Note</code></pre><p>上面模块的最后一行输出被声明的模块，即变量Note。</p><h3 id="b-表单"><a href="#b-表单" class="headerlink" title="b. 表单"></a>b. 表单</h3><h4 id="将notes保存进组件状态中"><a href="#将notes保存进组件状态中" class="headerlink" title="将notes保存进组件状态中"></a>将notes保存进组件状态中</h4><p>用useStates定义状态：</p><pre><code class="jsx">//App.jsximport &#123; useState &#125; from &#39;react&#39;import Note from &#39;./components/Note&#39;const App = (props) =&gt; &#123;  const [notes, setNotes] = useState(props.notes) //定义状态，用props中的notes来初始化该状态  return (    &lt;div&gt;      &lt;h1&gt;Notes&lt;/h1&gt;      &lt;ul&gt;        &#123;notes.map(note =&gt;           &lt;Note key=&#123;note.id&#125; note=&#123;note&#125; /&gt;        )&#125;      &lt;/ul&gt;    &lt;/div&gt;  )&#125;export default App </code></pre><p>添加HTML表单到组件中，表单用于添加新的笔记(notes)：</p><pre><code class="jsx">const App = (props) =&gt; &#123;  const [notes, setNotes] = useState(props.notes)  const addNote = (event) =&gt; &#123;    event.preventDefault()    console.log(&#39;button clicked&#39;, event.target)  &#125;  return (    &lt;div&gt;      &lt;h1&gt;Notes&lt;/h1&gt;      &lt;ul&gt;        &#123;notes.map(note =&gt;           &lt;Note key=&#123;note.id&#125; note=&#123;note&#125; /&gt;        )&#125;      &lt;/ul&gt;      &lt;form onSubmit=&#123;addNote&#125;&gt;         &lt;input /&gt;        &lt;button type=&quot;submit&quot;&gt;save&lt;/button&gt;      &lt;/form&gt;       &lt;/div&gt;  )&#125;</code></pre><p>对比原来的代码，我们添加了<em>addNote</em>函数作为表单元素的事件处理器，函数会在通过点击提交按钮提交表单时被调用。</p><p><em>addNote</em>的event参数是触发对事件处理器函数进行调用的事件。</p><p>在<em>addNote</em>函数体中我们还调用了*event.preventDefault()*方法，如果不这样做的话，在提交表单时页面会重新加载。</p><h4 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h4><p>添加新的状态，给状态命名为newNote，新的状态用来存储用户提交的输入并且让我们将它设置成输入元素的<em>value</em>属性：</p><pre><code class="jsx">//App.jsxconst App = (props) =&gt; &#123;  const [notes, setNotes] = useState(props.notes)  const [newNote, setNewNote] = useState(    &#39;a new note...&#39;  )   const addNote = (event) =&gt; &#123;    event.preventDefault()    console.log(&#39;button clicked&#39;, event.target)  &#125;  return (    &lt;div&gt;      &lt;h1&gt;Notes&lt;/h1&gt;      &lt;ul&gt;        &#123;notes.map(note =&gt;           &lt;Note key=&#123;note.id&#125; note=&#123;note&#125; /&gt;        )&#125;      &lt;/ul&gt;      &lt;form onSubmit=&#123;addNote&#125;&gt;        &lt;input value=&#123;newNote&#125; /&gt;        &lt;button type=&quot;submit&quot;&gt;save&lt;/button&gt;      &lt;/form&gt;       &lt;/div&gt;  )&#125;</code></pre><p><strong>注意</strong>：只是让input的value属性接收newNote并不会让input改变时，input的显示内容也改变。因为input在没有注册事件处理器时，改变input的value属性不会触发事件，而没有事件触发也就意味着App组件的状态没有改变(没有调用setNewNote方法)，也就不会让页面重新渲染。就算用其它方式(比如调用render方法)让App重新渲染，由于newNote这个状态始终没有发生改变，input的value属性就一直都是newNote的初始值。</p><p>因为我们将App的一个状态赋给了input元素的value属性，所以App组件现在在控制input元素的行为。但是现在我们只是让input的value接收状态newNote的值，如果想要在对input进行改变时，input的value也随之改变，我们需要注册<em>onChange</em>事件：</p><pre><code class="jsx">  const handleNoteChange = (event) =&gt; &#123;    console.log(event.target.value)    setNewNote(event.target.value)  &#125;  return (    &lt;div&gt;      &lt;h1&gt;Notes&lt;/h1&gt;      &lt;ul&gt;        &#123;notes.map(note =&gt;           &lt;Note key=&#123;note.id&#125; note=&#123;note&#125; /&gt;        )&#125;      &lt;/ul&gt;      &lt;form onSubmit=&#123;addNote&#125;&gt;        &lt;input          value=&#123;newNote&#125;          onChange=&#123;handleNoteChange&#125;        /&gt;        &lt;button type=&quot;submit&quot;&gt;save&lt;/button&gt;      &lt;/form&gt;       &lt;/div&gt;  )&#125;</code></pre><p>这里我们不需要调用*event.preventDefault()*方法，因为在input改变时<strong>没有默认行为发生</strong>。</p><p>定义创建新笔记的方法：</p><pre><code class="jsx">const addNote = (event) =&gt; &#123;  event.preventDefault()  const noteObject = &#123;    content: newNote,    important: Math.random() &lt; 0.5,    id: notes.length + 1,  &#125;  setNotes(notes.concat(noteObject))  setNewNote(&#39;&#39;)&#125;</code></pre><h3 id="c-从服务器获取数据"><a href="#c-从服务器获取数据" class="headerlink" title="c. 从服务器获取数据"></a>c. 从服务器获取数据</h3><h4 id="工具-JSON-server"><a href="#工具-JSON-server" class="headerlink" title="工具-JSON server"></a>工具-JSON server</h4><p>使用npm全局安装：</p><pre><code class="shell">npm install -g json-server</code></pre><p>json-server默认端口为3000，我们可以通过–port选项使用另外的端口；–watch选项让服务器自动检测任何对db.json的保存改动：</p><pre><code class="shell">json-server --port 3001 --watch db.json</code></pre><p>如果没有全局安装json-server，也可以使用下面的命令：</p><pre><code class="shell">npx json-server --port 3001 --watch db.json</code></pre><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p>识别npm项目的一个方式是看项目根目录有没有package.json文件。</p><p>安装axios：</p><pre><code class="shell">npm install axios</code></pre><p>通过下面的命令将<em>json-server</em>安装成开发者依赖：</p><pre><code class="shell">npm install json-server --save-dev</code></pre><p>在package.json脚本部分添加：</p><pre><code>&quot;server&quot;: &quot;json-server -p3001 --watch db.json&quot;</code></pre><p>现在我们可以方便地在根目录使用命令：</p><pre><code class="shell">npm run server</code></pre><p>来启动json-server，并且是以想要的选项来启动。</p><p>我们用npm安装了两个软件(暂且叫软件吧)：</p><pre><code class="shell">npm install axiosnpm install json-server --save-dev</code></pre><p>可以看到参数有些不同：axios被安装成应用的运行时依赖，因为程序的执行需要该库的存在；而json-server被安装成开发者依赖(–save-dev)，因为应用本身不要求它，它是为了帮助开发而安装的。</p><h4 id="Axios和promises"><a href="#Axios和promises" class="headerlink" title="Axios和promises"></a>Axios和promises</h4><p>添加下面的代码到main.jsx中：</p><pre><code class="jsx">import axios from &#39;axios&#39;const promise = axios.get(&#39;http://localhost:3001/notes&#39;)console.log(promise)const promise2 = axios.get(&#39;http://localhost:3001/foobar&#39;)console.log(promise2)</code></pre><p>Axios的方法get返回一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises">promise</a>。</p><p>如果我们想访问promise表示的操作的结果，必须给promise注册一个事件处理器，这是通过使用方法<em>then</em>实现的：</p><pre><code class="jsx">axios  .get(&#39;http://localhost:3001/notes&#39;)  .then(response =&gt; &#123;    const notes = response.data    console.log(notes)  &#125;)</code></pre><h4 id="Effect钩子"><a href="#Effect钩子" class="headerlink" title="Effect钩子"></a>Effect钩子</h4><p>React官方对Effect钩子的描述：Effect钩子让你能够在函数组件上造成副作用。取数据，设置订阅，和手动修改React组件中的DOM都是副作用的例子。</p><p>修改App.jsx:</p><pre><code class="jsx">import &#123; useState, useEffect &#125; from &#39;react&#39;import axios from &#39;axios&#39;import Note from &#39;./components/Note&#39;const App = () =&gt; &#123;  const [notes, setNotes] = useState([])  const [newNote, setNewNote] = useState(&#39;&#39;)  const [showAll, setShowAll] = useState(true)  useEffect(() =&gt; &#123;    console.log(&#39;effect&#39;)    axios      .get(&#39;http://localhost:3001/notes&#39;)      .then(response =&gt; &#123;        console.log(&#39;promise fulfilled&#39;)        setNotes(response.data)      &#125;)  &#125;, [])  console.log(&#39;render&#39;, notes.length, &#39;notes&#39;)  // ...&#125;</code></pre><p>几个log打印顺序：</p><pre><code>render 0 noteseffectpromise fulfilledrender 3 notes</code></pre><p>打印顺序的解释：</p><ol><li>App组件被渲染，App函数代码要被执行一遍，所以会打印render 0 notes。</li><li>在App组件第一次渲染完成后，useEffect注册的事件处理器开始执行，所以会打印effect。</li><li>接着执行，调用了axios的get方法，然后对get的返回结果调用then方法，由于数据正常接收，then方法中注册的事件处理器会开始执行，导致promise fulfilled被打印。接着notes数据被设置。</li><li>由于上一步改动了组件状态，组件会被重新渲染，导致render 3 notes被打印。</li></ol><p><strong>注意</strong>：默认情况下useEffect注册的函数会在组件每一次重新渲染时被执行，这里之所以只在第一次组件渲染后执行，是因为我们传给useEffect的第二个参数为[]—空数组，对于useEffect参数的讨论详见<a href="https://react.dev/reference/react/useEffect#parameters%E3%80%82">https://react.dev/reference/react/useEffect#parameters。</a></p><h4 id="开发时的运行时环境"><a href="#开发时的运行时环境" class="headerlink" title="开发时的运行时环境"></a>开发时的运行时环境</h4><p>下面的图片描述了当前我们的notes应用的组成：<img src="/..%5Cimages%5CFullstack%5Cpart2%5Cnotes%E5%BA%94%E7%94%A8%E7%9A%84%E7%BB%84%E6%88%90.png" alt="notes应用的组成"></p><p>组成我们的React应用的JS代码运行在浏览器中。浏览器从React开发服务器获取JS代码，开发服务器将真正的代码文件转换成浏览器能够理解的格式，它将来自不同文件的JS代码糅合成一个文件。</p><p>运行在浏览器中的React应用从<em>json-server</em>中获取JSON数据，而<em>json-server</em>从db.json获取数据。</p><h3 id="d-修改服务器中的数据"><a href="#d-修改服务器中的数据" class="headerlink" title="d. 修改服务器中的数据"></a>d. 修改服务器中的数据</h3><h4 id="向服务器发送数据"><a href="#向服务器发送数据" class="headerlink" title="向服务器发送数据"></a>向服务器发送数据</h4><p>修改负责创建新笔记的事件处理器：</p><pre><code class="jsx">addNote = event =&gt; &#123;  event.preventDefault()  const noteObject = &#123;    content: newNote,    important: Math.random() &lt; 0.5,  &#125;  axios    .post(&#39;http://localhost:3001/notes&#39;, noteObject)    .then(response =&gt; &#123;      setNotes(notes.concat(response.data))      setNewNote(&#39;&#39;)    &#125;)&#125;</code></pre><p>这里我们不再自己设置新note的id，而是让服务器设置。</p><h4 id="将与后端通信的逻辑提取成单独的模块"><a href="#将与后端通信的逻辑提取成单独的模块" class="headerlink" title="将与后端通信的逻辑提取成单独的模块"></a>将与后端通信的逻辑提取成单独的模块</h4><p>在加入与后端通信的逻辑后App组件变得臃肿了。出于<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">单一职责准则</a>，我们考虑将与服务器通信的逻辑提取成专门的模块。</p><p>创建<em>src&#x2F;services</em>目录并且在该目录添加一个叫做notes.js的文件：</p><pre><code class="js">import axios from &#39;axios&#39;const baseUrl = &#39;http://localhost:3001/notes&#39;const getAll = () =&gt; &#123;  const request = axios.get(baseUrl)  return request.then(response =&gt; response.data)&#125;const create = newObject =&gt; &#123;  const request = axios.post(baseUrl, newObject)  return request.then(response =&gt; response.data)&#125;const update = (id, newObject) =&gt; &#123;  const request = axios.put(`$&#123;baseUrl&#125;/$&#123;id&#125;`, newObject)  return request.then(response =&gt; response.data)&#125;&#123;   getAll,   create,   update &#125;</code></pre><p>App组件使用import来获取对上面定义的模块的使用权：</p><pre><code class="jsx">import noteService from &#39;./services/notes&#39;const App = () =&gt; &#123;</code></pre><p>模块的几个函数(getAll, create, update)可以通过引入的变量<em>noteService</em>直接使用：</p><pre><code class="jsx">const App = () =&gt; &#123;  // ...  useEffect(() =&gt; &#123;    noteService // 看这里！！！！！！      .getAll()      .then(initialNotes =&gt; &#123;        setNotes(initialNotes)      &#125;)  &#125;, [])  const toggleImportanceOf = id =&gt; &#123;    const note = notes.find(n =&gt; n.id === id)    const changedNote = &#123; ...note, important: !note.important &#125;    noteService // 看这里！！！！！！      .update(id, changedNote)      .then(returnedNote =&gt; &#123;        setNotes(notes.map(note =&gt; note.id !== id ? note : returnedNote))      &#125;)  &#125;  const addNote = (event) =&gt; &#123;    event.preventDefault()    const noteObject = &#123;      content: newNote,      important: Math.random() &gt; 0.5    &#125;    noteService // 看这里！！！！！！      .create(noteObject)      .then(returnedNote =&gt; &#123;        setNotes(notes.concat(returnedNote))        setNewNote(&#39;&#39;)      &#125;)  &#125;  // ...&#125;</code></pre><h3 id="e-为React应用添加样式"><a href="#e-为React应用添加样式" class="headerlink" title="e. 为React应用添加样式"></a>e. 为React应用添加样式</h3><p>在普通HTML文件里类的定义是作为元素的<strong>class</strong>属性的：</p><pre><code class="html">&lt;li class=&quot;note&quot;&gt;some text...&lt;/li&gt;</code></pre><p>然而在React中我们要使用<strong>className</strong>属性:</p><pre><code class="jsx">return (    &lt;li className=&#39;note&#39;&gt;      &#123;note.content&#125;       &lt;button onClick=&#123;toggleImportance&#125;&gt;&#123;label&#125;&lt;/button&gt;    &lt;/li&gt;  )</code></pre><h2 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h2><h3 id="a-Node-js和Express"><a href="#a-Node-js和Express" class="headerlink" title="a. Node.js和Express"></a>a. Node.js和Express</h3><p>找一个目录，在终端执行<code>npm init</code>，会得到一个package.json文件：</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;test&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;scripts&quot;: &#123;    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,  &#125;,  &quot;author&quot;: &quot;&quot;,  &quot;license&quot;: &quot;ISC&quot;&#125;</code></pre><p>我们可以自己添加一点内容：</p><pre><code class="json">&#123;  // ...  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node index.js&quot;,    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  // ...&#125;</code></pre><p>创建文件index.js，键入几行JS代码，就可以测试一下我们的配置是否生效：</p><pre><code class="shell">node index.js//或者 npm start</code></pre><h4 id="简单的web服务器"><a href="#简单的web服务器" class="headerlink" title="简单的web服务器"></a>简单的web服务器</h4><p>首先编辑index.js的内容：</p><pre><code class="js">const http = require(&#39;http&#39;) //引入Node的内置web server模块// 创建新的web服务器，服务器注册了一个事件处理器，在每次HTTP请求到达地址// &quot;http://localhost:3001&quot;时调用它。const app = http.createServer((request, response) =&gt; &#123;  //响应状态码200，Content-Type设置为text/plain  response.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text/plain&#39; &#125;)      //返回内容为Hello World  response.end(&#39;Hello World&#39;)&#125;)//在端口3001监听const PORT = 3001app.listen(PORT)console.log(`Server running on port $&#123;PORT&#125;`)</code></pre><p>当前浏览器中的代码使用ES6模块，模块用export定义，用import引入以使用。然而Node.js使用所谓的<a href="https://en.wikipedia.org/wiki/CommonJS">CommonJS</a>模块，这是因为Node生态在JS在语言规范中支持模块前就对模块有需求了，现在Node.js也支持ES6模块，但是并不能完美的支持。</p><p>将代码改得更复杂一点：</p><pre><code class="js">const http = require(&#39;http&#39;)let notes = [  &#123;    id: 1,    content: &quot;HTML is easy&quot;,    important: true  &#125;,  &#123;    id: 2,    content: &quot;Browser can execute only JavaScript&quot;,    important: false  &#125;,  &#123;    id: 3,    content: &quot;GET and POST are the most important methods of HTTP protocol&quot;,    important: true  &#125;]const app = http.createServer((request, response) =&gt; &#123;  //注意这里的Content-Type发生了变化  response.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;application/json&#39; &#125;)    //将notes转换成JSON字符串  response.end(JSON.stringify(notes))&#125;)const PORT = 3001app.listen(PORT)console.log(`Server running on port $&#123;PORT&#125;`)</code></pre><h4 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h4><p>将Express加入项目依赖：</p><pre><code class="shell">npm install express</code></pre><p>此时查看项目<em>node_modules</em>目录，可以看到除了Express库，还有许多其它的库，这些库是express库的依赖和这些依赖的依赖。这些依赖被叫做我们项目的<a href="https://lexi-lambda.github.io/blog/2016/08/24/understanding-the-npm-dependency-model/">传递依赖</a> 。</p><p>在安装express后，package.json也会变化，主要是这一处：</p><pre><code class="json">&quot;express&quot;: &quot;^4.18.2&quot;</code></pre><p>npm使用的版本控制模型叫做语义版本控制。</p><p>版本号”4.18.2”前面的插入符”^”表示：当项目的依赖更新时，express的安装版本<strong>至少</strong>是”4.18.2”，可能会比”4.18.2”高，但是库的主版本号(由第一个主数字表示)必须相同。如果一个依赖的主号不变，那么其新版本应该是向后兼容的。</p><h4 id="web和express"><a href="#web和express" class="headerlink" title="web和express"></a>web和express</h4><p>回到我们的服务器demo，对其进行修改：</p><pre><code class="js">const express = require(&#39;express&#39;)//创建express应用const app = express()let notes = [  // ...]//定义两个路由app.get(&#39;/&#39;, (request, response) =&gt; &#123;  //因为参数是字符串，express自动设置Content-Type为text/html  response.send(&#39;&lt;h1&gt;Hello World!&lt;/h1&gt;&#39;)&#125;)app.get(&#39;/api/notes&#39;, (request, response) =&gt; &#123;  //不用手动将notes转成JSON字符串  response.json(notes)&#125;)const PORT = 3001app.listen(PORT, () =&gt; &#123;  console.log(`Server running on port $&#123;PORT&#125;`)&#125;)</code></pre><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h4><p>每次我们对服务器代码修改后，都要按<em>Ctrl+c</em>关闭服务器，然后再启动。为了解决这一问题，我们会安装 <a href="https://github.com/remy/nodemon">nodemon</a>，nodemon在启动后会监控启动nodemon命令的目录，如果目录里有保存的文件修改操作，nodemon会自动重启你的node应用。</p><p>安装nodemon：</p><pre><code class="shell">npm install --save-dev nodemon</code></pre><p>这次我们以nodemon启动我们的应用：</p><pre><code class="shell">node_modules/.bin/nodemon index.js</code></pre><p>我们还可以将上面的命令定义成npm脚本：</p><pre><code class="json">&#123;  // ..  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;node index.js&quot;,    &quot;dev&quot;: &quot;nodemon index.js&quot;,    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  &#125;,  // ..&#125;</code></pre><p>注意我们这次没有指定node_modules&#x2F;.bin&#x2F;nodemon，而是直接使用nodemon，因为npm知道要从.bin目录搜索nodemon程序。</p><p>之后我们再以nodemon方式运行服务器就更简单了：</p><pre><code class="shell">npm run dev</code></pre><p>与<em>start</em>和<em>test</em>脚本命令不同，我们必须添加”run”到命令中，因为它不是一个原生(native)脚本。</p><h4 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h4><p>Representational State Transfer, 又名 REST，2000年由Roy Fielding的<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">论文</a>引入。REST是一种用于构建弹性web应用的体系结构风格。事实上世界上大部分所谓的”REST”API都没有满足Fielding(人名)在论文中列出的准则。</p><p>一个示例：</p><table><thead><tr><th align="left">URL</th><th align="left">动词</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">notes&#x2F;10</td><td align="left">GET</td><td align="left">取单个资源</td></tr><tr><td align="left">notes</td><td align="left">GET</td><td align="left">取资源集中的所有资源</td></tr><tr><td align="left">notes</td><td align="left">POST</td><td align="left">基于请求数据创建新资源</td></tr><tr><td align="left">notes&#x2F;10</td><td align="left">DELETE</td><td align="left">删除指定的资源</td></tr><tr><td align="left">notes&#x2F;10</td><td align="left">PUT</td><td align="left">用请求数据替换指定资源的全部</td></tr><tr><td align="left">notes&#x2F;10</td><td align="left">PATCH</td><td align="left">用请求数据替换指定资源的部分</td></tr></tbody></table><h4 id="取单个资源"><a href="#取单个资源" class="headerlink" title="取单个资源"></a>取单个资源</h4><p>在express中我们使用”:”语法来为路由定义参数：</p><pre><code class="js">app.get(&#39;/api/notes/:id&#39;, (request, response) =&gt; &#123;  const id = Number(request.params.id)  const note = notes.find(note =&gt; note.id === id)    if (note) &#123;    response.json(note)  &#125; else &#123;    response.status(404).end()  &#125;&#125;)</code></pre><p>一个请求的路由中的<em>id</em>参数可以通过request对象获取：</p><pre><code class="js">const id = request.params.id</code></pre><p>当所查询的id在notes中找不到时我们使用response对象的status方法来设置响应码为404，并且以end()方法表示我们对请求做出响应，但是响应不包含数据。</p><h4 id="删除资源"><a href="#删除资源" class="headerlink" title="删除资源"></a>删除资源</h4><pre><code class="js">app.delete(&#39;/api/notes/:id&#39;, (request, response) =&gt; &#123;  const id = Number(request.params.id)  notes = notes.filter(note =&gt; note.id !== id)  response.status(204).end()&#125;)</code></pre><p>删除我们以状态码 <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-204-no-content">204 no content</a>来响应请求，并且响应不返回数据。</p><p>对于一个对应资源不存在的DELETE请求应该以什么状态码返回并没有共识。仅有的选项是204或404，这里出于简单性我们选择204。</p><h4 id="VS-Code插件：REST-client"><a href="#VS-Code插件：REST-client" class="headerlink" title="VS Code插件：REST client"></a>VS Code插件：REST client</h4><p>REST client允许你在VS Code中发送请求和查看请求结果。</p><p>简单使用步骤：</p><ol><li>在项目根目录下创建目录<em>requests</em>，我们将把所有REST client请求文件保存在该目录中，请求文件以.rest结尾。</li><li>创建<em>get_all_notes.rest</em> 文件，内容为<code>GET http://localhost:3001/api/notes</code>。</li><li>点击<code>GET http://localhost:3001/api/notes</code>上方的<code>Send Request</code>即可发送请求并查看响应结果。</li></ol><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><pre><code class="js">const express = require(&#39;express&#39;)const app = express()app.use(express.json())//...app.post(&#39;/api/notes&#39;, (request, response) =&gt; &#123;  const note = request.body  console.log(note)  response.json(note)&#125;)</code></pre><p>注意<code>app.use(express.json())</code>这一句很重要，没有这一句reques下面的事件处理器接收到的数据将是undefined。json-parser函数(就是<code>app.use(express.json())</code>带来的效果)会在事件处理器处理请求前将JSON数据转换成JS对象。</p><h4 id="关于请求类型"><a href="#关于请求类型" class="headerlink" title="关于请求类型"></a>关于请求类型</h4><p><a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-common-method-properties">HTTP标准</a>讨论了两个与请求类型有关的性质：安全性和幂等性。</p><p><strong>注意</strong>：这两个性质是HTTP标准的<strong>推荐</strong>，而不是<strong>保证</strong>。即我们设计应用程序时应该考虑这些性质，HTTP标准本身并不会保证这些性质。只要我们的应用坚持RESTful准则，这两个性质就能有保证。</p><p>HTTP GET和HEAD方法应该满足安全性要求：除了检索数据外对数据没有<strong>副作用</strong>。</p><p>HEAD与GET方法工作方式应该非常相似，除了它不会返回除状态码和响应头外的<strong>任何东西</strong>。当执行HEAD请求时<strong>响应体不会被返回</strong>。</p><p>任何除POST请求外的HTTP请求都应该是幂等的(<em>idempotent</em>)：</p><p>幂等方法表示进行大于0次相同的请求，副作用<strong>都与单次请求相同</strong>(除了发生错误或过期的情况)。<em>GET, HEAD, PUT 和 DELETE</em> 都共享该性质。</p><p>POST是唯一一个既不安全也不幂等的HTTP请求类型。</p><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>之间我们用到的 <a href="https://expressjs.com/en/api.html">json-parser</a>就是所谓的中间件(还记得<code>app.use(express.json())</code>这一句代码吗)。中间件事可以被用来处理<em>request</em> 和 <em>response</em>请求的函数。</p><p>实现自己的中间件：打印每一个发送到服务器的请求相关的信息。一个中间件是一个接受三个参数的函数：</p><pre><code class="js">const requestLogger = (request, response, next) =&gt; &#123;  console.log(&#39;Method:&#39;, request.method)  console.log(&#39;Path:  &#39;, request.path)  console.log(&#39;Body:  &#39;, request.body)  console.log(&#39;---&#39;)  next()&#125;</code></pre><p>函数体的最后一句中，<em>next</em>函数被调用，对下一次中间件产生控制作用。</p><p>使用中间件：</p><pre><code class="js">app.use(requestLogger)</code></pre><p>中间件以被express服务器对象的use方法注册的先后顺序被调用。</p><h3 id="b-部署应用到互联网"><a href="#b-部署应用到互联网" class="headerlink" title="b. 部署应用到互联网"></a>b. 部署应用到互联网</h3><h4 id="同源策略和CORS"><a href="#同源策略和CORS" class="headerlink" title="同源策略和CORS"></a>同源策略和CORS</h4><p>一个URL的源(origin)由协议(也叫模式),主机名和端口来定义。</p><pre><code>http://example.com:80/index.html  protocol: httphost: example.comport: 80</code></pre><p>当你访问一个网站时，服务器会响应一个HTML文件，该文件可能存在对外部资源的引用。当浏览器在HTML文件中看到对一个URL的引用时会发起请求，如果请求通过取HTML文件时的URL发出，则浏览器处理该请求不会有任何问题；然而，如果资源通过一个与源(source)HTML不同源(origin)的URL发出，浏览器一定会检查<em>Access-Control-Allow-origin</em>响应头，如果它包含*或者源HTML的URL，浏览器会处理该响应，否则浏览器会拒绝处理它并抛出错误。</p><p>同源策略是由浏览器实现的一个安全机制，目的是防止会话劫持和一些其它的安全漏洞。为了进行合法的跨域请求(请求不同源的URL)，W3C制定了叫CORS(Cross-Origin Resource Sharing)的机制。<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">维基百科</a></p><p>我们可以通过使用Node的<a href="https://github.com/expressjs/cors">cors</a>中间件允许来自其它源的请求。在后端项目中安装cors：</p><pre><code class="shell">npm install cors</code></pre><p>使用该中间件以允许来自所有域的请求：</p><pre><code class="js">const cors = require(&#39;cors&#39;)app.use(cors())</code></pre><p>这样前端就能工作了！</p><h4 id="从后端提供静态文件"><a href="#从后端提供静态文件" class="headerlink" title="从后端提供静态文件"></a>从后端提供静态文件</h4><p>在前端开发目录中执行：</p><pre><code class="shell">npm run build</code></pre><p>将会在项目根目录下生成一个dist目录，将dist目录拷贝到后端项目根目录下。之后可以从localhost:3001访问到前端。</p><p>在前端修改baseUrl:</p><pre><code class="js">const baseUrl = &#39;/api/notes&#39;</code></pre><p>当前产品部署的设置：</p><p><img src="/..%5Cimages%5CFullstack%5Cpart3%5C%E5%BD%93%E5%89%8Dnotes%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE.png" alt="当前notes应用设置"></p><p>然后将应用部署到代码托管网站中，之后产品布局再次发生变化：</p><p><img src="/..%5Cimages%5CFullstack%5Cpart3%5C%E9%83%A8%E7%BD%B2%E5%90%8Enotes%E5%BA%94%E7%94%A8%E8%AE%BE%E7%BD%AE.png" alt="部署后notes应用设置"></p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>在前端修改baseUrl后，部署到代码托管网站上的代码能被正常使用，但是开发环境下(<code>npm run dev</code>)的前端代码不能正常工作了，因为到后端的连接已经失效。</p><p>如果项目使用vite构建，将这个问题很好解决：</p><pre><code class="js">//vite.config.jsonimport &#123; defineConfig &#125; from &#39;vite&#39;import react from &#39;@vitejs/plugin-react&#39;// https://vitejs.dev/config/export default defineConfig(&#123;  plugins: [react()],  server: &#123;    proxy: &#123;      &#39;/api&#39;: &#123;        target: &#39;http://localhost:3001&#39;,        changeOrigin: true,      &#125;,    &#125;  &#125;,&#125;)</code></pre><p>(主要看server这一块)</p><h3 id="c-将数据保存到MongoDB"><a href="#c-将数据保存到MongoDB" class="headerlink" title="c. 将数据保存到MongoDB"></a>c. 将数据保存到MongoDB</h3><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>MongoDB是一种<a href="https://en.wikipedia.org/wiki/Document-oriented_database">文档数据库</a>(或者叫文档存储)，是一种计算机应用或数据存储系统，被设计来存储、检索和管理面向文档的数据(或者叫半结构化数据)。</p><p>面向文档数据库是<a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a>数据库主要分类的一种。</p><p>在后端项目文件夹中安装<a href="http://mongoosejs.com/index.html">Mongoose</a>：</p><pre><code class="shell">npm install mongoose</code></pre><p>与数据库建立连接：</p><pre><code class="js">//mongo.jsconst mongoose = require(&#39;mongoose&#39;)if (process.argv.length &lt; 3) &#123;    console.log(&#39;give password as argument&#39;)    process.exit(1)&#125;const password = process.argv[2]const url =    `mongodb+srv://fullstack:$&#123;password&#125;@cluster0.nc1rsng.mongodb.net/noteApp?retryWrites=true&amp;w=majority`mongoose.set(&#39;strictQuery&#39;, false)mongoose.connect(url)</code></pre><h4 id="模式-schema"><a href="#模式-schema" class="headerlink" title="模式(schema)"></a>模式(schema)</h4><p>在建立到数据库的连接后，我们定义note的<a href="http://mongoosejs.com/docs/guide.html">模式</a>和相匹配的<a href="http://mongoosejs.com/docs/models.html">模型</a>：</p><pre><code class="js">//mongo.jsconst noteSchema = new mongoose.Schema(&#123;  content: String,  important: Boolean,&#125;)const Note = mongoose.model(&#39;Note&#39;, noteSchema)</code></pre><p>类似Mongo的文档数据库是无模式的，意味着数据库本身不关心存储在数据库中的数据的结构。</p><p>Mongoose的理念是一个<strong>应用层面</strong>的模式被给到数据库中的数据，模式定义了存储到任意给定集(collection)的文档形状。</p><h4 id="创建和保存对象"><a href="#创建和保存对象" class="headerlink" title="创建和保存对象"></a>创建和保存对象</h4><p>接下来，应用在Note模型的帮助下创建了一个note对象：</p><pre><code class="js">//mongo.jsconst note = new Note(&#123;  content: &#39;HTML is Easy&#39;,  important: false,&#125;)</code></pre><p>模型是基于提供的参数创建新对象的所谓<em>构造器函数</em>。</p><p>保存对象到数据库是在save方法被调用时发生的，可以为该方法提供带事件处理器的then方法：</p><pre><code class="js">//mongo.jsnote.save().then(result =&gt; &#123;  console.log(&#39;note saved!&#39;)  mongoose.connection.close()&#125;)</code></pre><h4 id="连接后端到数据库"><a href="#连接后端到数据库" class="headerlink" title="连接后端到数据库"></a>连接后端到数据库</h4><p>模式的可配置选项：</p><pre><code class="js">noteSchema.set(&#39;toJSON&#39;, &#123;  transform: (document, returnedObject) =&gt; &#123;    returnedObject.id = returnedObject._id.toString()    delete returnedObject._id    delete returnedObject.__v  &#125;&#125;)</code></pre><h4 id="将数据库配置设计成单独的模块"><a href="#将数据库配置设计成单独的模块" class="headerlink" title="将数据库配置设计成单独的模块"></a>将数据库配置设计成单独的模块</h4><p>添加文件夹，命名为<em>models</em>。文件夹中添加问价<em>note.js</em>：</p><pre><code class="js">const mongoose = require(&#39;mongoose&#39;)mongoose.set(&#39;strictQuery&#39;, false)const url = process.env.MONGODB_URIconsole.log(&#39;connecting to&#39;, url)mongoose.connect(url)  .then(result =&gt; &#123;    console.log(&#39;connected to MongoDB&#39;)  &#125;)  .catch((error) =&gt; &#123;    console.log(&#39;error connecting to MongoDB:&#39;, error.message)  &#125;)const noteSchema = new mongoose.Schema(&#123;  content: String,  important: Boolean,&#125;)noteSchema.set(&#39;toJSON&#39;, &#123;  transform: (document, returnedObject) =&gt; &#123;    returnedObject.id = returnedObject._id.toString()    delete returnedObject._id    delete returnedObject.__v  &#125;&#125;)module.exports = mongoose.model(&#39;Note&#39;, noteSchema)</code></pre><p>定义Node模块与与定义ES6模块的方式有些不同，模块的公共接口通过设置一个值给<em>module.exports</em>定义。</p><p>通过添加下面的代码到index.js中来引入模块：</p><pre><code class="js">const Note = require(&#39;./models/note&#39;)</code></pre><p>硬编码数据库地址到代码中并不是个好主意，所以我们通过<em>MONGODB_URI</em>环境变量来将地址传递给应用。</p><p>定义环境变量的值的方式有许多种，一种是当程序启动时：</p><pre><code class="shell">MONGODB_URI=address_here npm run dev</code></pre><p>更精妙的方式是使用<a href="https://github.com/motdotla/dotenv#readme">dotenv</a>库，可以通过npm安装它：</p><pre><code class="shell">npm install dotenv</code></pre><p>为了使用该库，我们创建一个叫.env的文件，环境变量就定义在该文件中：</p><pre><code class="env">MONGODB_URI=mongodb+srv://fullstack:&lt;password&gt;@cluster0.o1opl.mongodb.net/noteApp?retryWrites=true&amp;w=majorityPORT=3001</code></pre><p>记得要在.gitignore中设置让git忽略该文件！</p><p>修改inde.js文件：</p><pre><code class="js">require(&#39;dotenv&#39;).config()const express = require(&#39;express&#39;)const app = express()const Note = require(&#39;./models/note&#39;)// ..const PORT = process.env.PORTapp.listen(PORT, () =&gt; &#123;  console.log(`Server running on port $&#123;PORT&#125;`)&#125;)</code></pre><h4 id="在路由处理器中使用数据库"><a href="#在路由处理器中使用数据库" class="headerlink" title="在路由处理器中使用数据库"></a>在路由处理器中使用数据库</h4><p>像这样创建新的note：</p><pre><code class="js">app.post(&#39;/api/notes&#39;, (request, response) =&gt; &#123;  const body = request.body  if (body.content === undefined) &#123;    return response.status(400).json(&#123; error: &#39;content missing&#39; &#125;)  &#125;  const note = new Note(&#123;    content: body.content,    important: body.important || false,  &#125;)  note.save().then(savedNote =&gt; &#123;    response.json(savedNote)  &#125;)&#125;)</code></pre><h4 id="将错误处理移动到中间件中"><a href="#将错误处理移动到中间件中" class="headerlink" title="将错误处理移动到中间件中"></a>将错误处理移动到中间件中</h4><p>让我们修改一下&#x2F;api&#x2F;notes&#x2F;:id路由的处理器以让它将error传递给<em>next</em>函数，next作为处理器的第三个参数被传入：</p><pre><code class="js">app.get(&#39;/api/notes/:id&#39;, (request, response, next) =&gt; &#123;  Note.findById(request.params.id)    .then(note =&gt; &#123;      if (note) &#123;        response.json(note)      &#125; else &#123;        response.status(404).end()      &#125;    &#125;)    .catch(error =&gt; next(error))&#125;)</code></pre><p>express<a href="https://expressjs.com/en/guide/error-handling.html">错误处理器</a>以一个接收四个参数的函数来定义的中间件：</p><pre><code class="js">const errorHandler = (error, request, response, next) =&gt; &#123;  console.error(error.message)  if (error.name === &#39;CastError&#39;) &#123;    return response.status(400).send(&#123; error: &#39;malformatted id&#39; &#125;)  &#125;   next(error)&#125;// this has to be the last loaded middleware.app.use(errorHandler)</code></pre><h4 id="中间件加载的顺序"><a href="#中间件加载的顺序" class="headerlink" title="中间件加载的顺序"></a>中间件加载的顺序</h4><p>中间件的执行顺序与它们被express用app.use加载的顺序相同。我们所使用的中间件的顺序：</p><pre><code class="js">app.use(express.static(&#39;build&#39;))app.use(express.json())app.use(requestLogger)app.post(&#39;/api/notes&#39;, (request, response) =&gt; &#123;  const body = request.body  // ...&#125;)const unknownEndpoint = (request, response) =&gt; &#123;  response.status(404).send(&#123; error: &#39;unknown endpoint&#39; &#125;)&#125;// handler of requests with unknown endpointapp.use(unknownEndpoint)const errorHandler = (error, request, response, next) =&gt; &#123;  // ...&#125;// handler of requests with result to errorsapp.use(errorHandler)</code></pre><h3 id="b-验证和ESLint"><a href="#b-验证和ESLint" class="headerlink" title="b. 验证和ESLint"></a>b. 验证和ESLint</h3><p>到现在为止我们的对数据验证的方式是在路由处理器中测试接收到的数据：</p><pre><code class="js">app.post(&#39;/api/notes&#39;, (request, response) =&gt; &#123;  const body = request.body  if (body.content === undefined) &#123; // 测试content是否为空    return response.status(400).json(&#123; error: &#39;content missing&#39; &#125;)  &#125;  // ...&#125;)</code></pre><p>一个更好的验证在数据存到数据库前验证其格式的方式是使用Mongoose带有的<a href="https://mongoosejs.com/docs/validation.html">validation</a>功能，我们可以为模式的每一个字段指定验证规则：</p><pre><code class="js">const noteSchema = new mongoose.Schema(&#123;  content: &#123;    type: String,    minLength: 5,    required: true  &#125;,  important: Boolean&#125;)</code></pre><p>minLength和required验证器是Mongoose <a href="https://mongoosejs.com/docs/validation.html#built-in-validators">built-in</a>的验证器。Mongoose<a href="https://mongoosejs.com/docs/validation.html#custom-validators">自定义验证器</a>允许我们创建自己的验证器。</p><p>存违反任意一个验证器限制的对象到数据库会抛出异常：</p><pre><code class="js">app.post(&#39;/api/notes&#39;, (request, response, next) =&gt; &#123;  const body = request.body  const note = new Note(&#123;    content: body.content,    important: body.important || false,  &#125;)  note.save()    .then(savedNote =&gt; &#123;      response.json(savedNote)    &#125;)    .catch(error =&gt; next(error)&#125;)</code></pre><p>让我们扩展我们的错误处理器，让它可以处理这些验证器错误：</p><pre><code class="js">const errorHandler = (error, request, response, next) =&gt; &#123;  console.error(error.message)  if (error.name === &#39;CastError&#39;) &#123;    return response.status(400).send(&#123; error: &#39;malformatted id&#39; &#125;)  &#125; else if (error.name === &#39;ValidationError&#39;) &#123;    return response.status(400).json(&#123; error: error.message &#125;)  &#125;  next(error)&#125;</code></pre><p>现在让我们在修改数据库中的某条数据前也要进行验证，相比之下<em>findOneAndUpdate</em>默认不会对参数进行验证，所以要验证的话稍稍麻烦一点：</p><pre><code class="js">app.put(&#39;/api/notes/:id&#39;, (request, response, next) =&gt; &#123;  const &#123; content, important &#125; = request.body  Note.findByIdAndUpdate(    request.params.id,     &#123; content, important &#125;,    &#123; new: true, runValidators: true, context: &#39;query&#39; &#125;  )     .then(updatedNote =&gt; &#123;      response.json(updatedNote)    &#125;)    .catch(error =&gt; next(error))&#125;)</code></pre><h4 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h4><p>摘自维基百科：</p><p>lint或linter指任何检测并且标记编程语言错误(包括风格错误)的工具。类Lint工具通常进行源代码的<strong>静态分析</strong>。</p><p>许多语言都有其对应的Lint工具，就JS而言，当前领先的工具是 <a href="https://eslint.org/">ESlint</a>。</p><p>让我们将ESLint安装成一个开发依赖,并且初始化默认ESlint配置：</p><pre><code class="shell">npm install eslint --save-devnpx eslint --init</code></pre><p>跟着一步一步的选择，我选择了airbnb代码风格。ESLint会生成一个配置文件*.eslintrc.js*。</p><p>检查并且验证一个像index.js这样的文件可以这样做：</p><pre><code class="shell">npx eslint index.js</code></pre><p>现在如果我们执行<code>npx eslint index.js</code>会让dist目录也被检测，为了避免该问题我们需要创建 <a href="https://eslint.org/docs/user-guide/configuring#ignoring-files-and-directories">.eslintignore</a>文件并输入下面的内容：</p><pre><code>dist</code></pre><p>为了让我们一直能够看到语法错误，我们可以安装VSCode ESlint。</p><h2 id="part4"><a href="#part4" class="headerlink" title="part4"></a>part4</h2><h3 id="a-后端应用的结构，测试入门"><a href="#a-后端应用的结构，测试入门" class="headerlink" title="a. 后端应用的结构，测试入门"></a>a. 后端应用的结构，测试入门</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>在进入测试话题前让我们先修改后端项目结构来满足Node.js的最佳实践。我们的目标是将结构改造成下面的样子：</p><pre><code>├── index.js├── app.js├── build│   └── ...├── controllers│   └── notes.js├── models│   └── note.js├── package-lock.json├── package.json├── utils│   ├── config.js│   ├── logger.js│   └── middleware.js  </code></pre><p>让我们将所有向终端打印操作分离成单独的模块<em>utils&#x2F;logger.js</em>:</p><pre><code class="js">const info = (...params) =&gt; &#123;  console.log(...params)&#125;const error = (...params) =&gt; &#123;  console.error(...params)&#125;module.exports = &#123;  info, error&#125;</code></pre><p>为什么这样做：如果我们想要写日志到文件或者发送日志到像<a href="https://www.graylog.org/">graylog</a>或者<a href="https://papertrailapp.com/">papertrail</a>这样的外部日志设备，我们只用在一个地方修改代码。</p><p>对启动应用的index.js文件的内容进行简化：</p><pre><code class="js">const app = require(&#39;./app&#39;) // the actual Express applicationconst config = require(&#39;./utils/config&#39;)const logger = require(&#39;./utils/logger&#39;)app.listen(config.PORT, () =&gt; &#123;  logger.info(`Server running on port $&#123;config.PORT&#125;`)&#125;)</code></pre><p>index.js只是从app.js引入真正的应用并且启动应用。</p><p>为什么这样做：这种结构的其中一个优点是现在可以在HTTP API调用层面测试应用而不用通过网络在HTTP层面进行调用，这样会让测试的执行更快。</p><p>环境变量的处理提取到utils&#x2F;config.js:</p><pre><code class="js">require(&#39;dotenv&#39;).config()const PORT = process.env.PORTconst MONGODB_URI = process.env.MONGODB_URImodule.exports = &#123;  MONGODB_URI,  PORT&#125;</code></pre><p>路由处理器也要被移动到一个专门的模块。路由的事件处理器通常被叫做<em>controllers</em>，因为我们创建<em>controllers</em>目录。所有与notes相关的路由现在都在<em>controllers</em>目录下的notes.js模块中：</p><pre><code class="js">//notes.jsconst notesRouter = require(&#39;express&#39;).Router()const Note = require(&#39;../models/note&#39;)notesRouter.get(&#39;/&#39;, (request, response) =&gt; &#123;  Note.find(&#123;&#125;).then(notes =&gt; &#123;    response.json(notes)  &#125;)&#125;)notesRouter.get(&#39;/:id&#39;, (request, response, next) =&gt; &#123;  Note.findById(request.params.id)    .then(note =&gt; &#123;      if (note) &#123;        response.json(note)      &#125; else &#123;        response.status(404).end()      &#125;    &#125;)    .catch(error =&gt; next(error))&#125;)notesRouter.post(&#39;/&#39;, (request, response, next) =&gt; &#123;  const body = request.body  const note = new Note(&#123;    content: body.content,    important: body.important || false,  &#125;)  note.save()    .then(savedNote =&gt; &#123;      response.json(savedNote)    &#125;)    .catch(error =&gt; next(error))&#125;)notesRouter.delete(&#39;/:id&#39;, (request, response, next) =&gt; &#123;  Note.findByIdAndRemove(request.params.id)    .then(() =&gt; &#123;      response.status(204).end()    &#125;)    .catch(error =&gt; next(error))&#125;)notesRouter.put(&#39;/:id&#39;, (request, response, next) =&gt; &#123;  const body = request.body  const note = &#123;    content: body.content,    important: body.important,  &#125;  Note.findByIdAndUpdate(request.params.id, note, &#123; new: true &#125;)    .then(updatedNote =&gt; &#123;      response.json(updatedNote)    &#125;)    .catch(error =&gt; next(error))&#125;)module.exports = notesRouter</code></pre><p>在文件第一行我们创建了一个<a href="http://expressjs.com/en/api.html#router">router</a>对象。router对像实际上就是一个中间件，可以用来在一个单独的地方定义”相关路由”，通常被放进自己的模块。</p><p>修改app.js：</p><pre><code class="js">const config = require(&#39;./utils/config&#39;)const express = require(&#39;express&#39;)const app = express()const cors = require(&#39;cors&#39;)const notesRouter = require(&#39;./controllers/notes&#39;)const middleware = require(&#39;./utils/middleware&#39;)const logger = require(&#39;./utils/logger&#39;)const mongoose = require(&#39;mongoose&#39;)mongoose.set(&#39;strictQuery&#39;, false)logger.info(&#39;connecting to&#39;, config.MONGODB_URI)mongoose.connect(config.MONGODB_URI)  .then(() =&gt; &#123;    logger.info(&#39;connected to MongoDB&#39;)  &#125;)  .catch((error) =&gt; &#123;    logger.error(&#39;error connecting to MongoDB:&#39;, error.message)  &#125;)app.use(cors())app.use(express.static(&#39;build&#39;))app.use(express.json())app.use(middleware.requestLogger)app.use(&#39;/api/notes&#39;, notesRouter)app.use(middleware.unknownEndpoint)app.use(middleware.errorHandler)module.exports = app</code></pre><p>我们的自定义中间件被移动到一个新的<em>utils&#x2F;middleware.js</em>模块：</p><pre><code class="js">const logger = require(&#39;./logger&#39;)const requestLogger = (request, response, next) =&gt; &#123;  logger.info(&#39;Method:&#39;, request.method)  logger.info(&#39;Path:  &#39;, request.path)  logger.info(&#39;Body:  &#39;, request.body)  logger.info(&#39;---&#39;)  next()&#125;const unknownEndpoint = (request, response) =&gt; &#123;  response.status(404).send(&#123; error: &#39;unknown endpoint&#39; &#125;)&#125;const errorHandler = (error, request, response, next) =&gt; &#123;  logger.error(error.message)  if (error.name === &#39;CastError&#39;) &#123;    return response.status(400).send(&#123; error: &#39;malformatted id&#39; &#125;)  &#125; else if (error.name === &#39;ValidationError&#39;) &#123;    return response.status(400).json(&#123; error: error.message &#125;)  &#125;  next(error)&#125;module.exports = &#123;  requestLogger,  unknownEndpoint,  errorHandler&#125;</code></pre><p>与数据库建立连接的责任已经交给了app.js，models目录下的note.js只需要为notes定义Mongoose模式：</p><pre><code class="js">const mongoose = require(&#39;mongoose&#39;)const noteSchema = new mongoose.Schema(&#123;  content: &#123;    type: String,    required: true,    minlength: 5  &#125;,  important: Boolean,&#125;)noteSchema.set(&#39;toJSON&#39;, &#123;  transform: (document, returnedObject) =&gt; &#123;    returnedObject.id = returnedObject._id.toString()    delete returnedObject._id    delete returnedObject.__v  &#125;&#125;)module.exports = mongoose.model(&#39;Note&#39;, noteSchema)</code></pre><h4 id="测试Node应用"><a href="#测试Node应用" class="headerlink" title="测试Node应用"></a>测试Node应用</h4><p>在这门课程中我们使用<a href="https://jestjs.io/">jest</a>测试库。</p><p>安装jest：</p><pre><code class="shell">npm install --save-dev jest</code></pre><p>package.json中定义npm脚本：</p><pre><code>&quot;test&quot;: &quot;jest --verbose&quot;</code></pre><p>编写<em>tests&#x2F;reverse.test.js</em>:</p><pre><code class="js">const reverse = require(&#39;../utils/for_testing&#39;).reverse//引入要测试的函数test(&#39;reverse of a&#39;, () =&gt; &#123;  const result = reverse(&#39;a&#39;)  expect(result).toBe(&#39;a&#39;)  //expect将result包装成一个对象，该对象提供一系列比较器函数，&#39;toBe&#39;就是其中一个&#125;)//test函数的第一个参数是对测试的描述，第二个函数是一个参数，定义了测试用例的功能test(&#39;reverse of react&#39;, () =&gt; &#123;  const result = reverse(&#39;react&#39;)  expect(result).toBe(&#39;tcaer&#39;)&#125;)test(&#39;reverse of releveler&#39;, () =&gt; &#123;  const result = reverse(&#39;releveler&#39;)  expect(result).toBe(&#39;releveler&#39;)&#125;)</code></pre><p>此时ESLint会抱怨<em>test</em>和<em>expect</em>命令不存在，需要修改.eslintrc.js:</p><pre><code class="js">module.exports = &#123;  &#39;env&#39;: &#123;    &#39;commonjs&#39;: true,    &#39;es2021&#39;: true,    &#39;node&#39;: true,    &#39;jest&#39;: true,  &#125;,  // ...&#125;</code></pre><p>jest期望测试文件的名字都包含.test。</p><h3 id="b-测试后端"><a href="#b-测试后端" class="headerlink" title="b. 测试后端"></a>b. 测试后端</h3><p>因为我们的应用后端相对简单，我们决定通过应用(包括数据库)的REST API来测试它。这种一个系统的多个组件被当成一组来测试的测试叫做<a href="https://en.wikipedia.org/wiki/Integration_testing">集成测试</a>。</p><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><p>Node的传统是用<em>NODE_ENV</em>环境变量来定义应用的执行模式。对于开发和测试定义不同的模式在实践中很常见。接下来让我们改变<em>package.json</em>中的scripts以让<em>NODE_ENV</em>在运行测试的时候得到值<em>test</em>:</p><pre><code class="json">&#123;  // ...  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;NODE_ENV=production node index.js&quot;,    &quot;dev&quot;: &quot;NODE_ENV=development nodemon index.js&quot;,    &quot;test&quot;: &quot;NODE_ENV=test jest --verbose --runInBand&quot;    &quot;build:ui&quot;: &quot;rm -rf build &amp;&amp; cd ../frontend/ &amp;&amp; npm run build &amp;&amp; cp -r build ../backend&quot;,    &quot;deploy&quot;: &quot;fly deploy&quot;,    &quot;deploy:full&quot;: &quot;npm run build:ui &amp;&amp; npm run deploy&quot;,    &quot;logs:prod&quot;: &quot;fly logs&quot;,    &quot;lint&quot;: &quot;eslint .&quot;,  &#125;,  // ...&#125;</code></pre><p>jest的选项–runInBand的作用：防止jest并行地运行测试。</p><p>我们在我们的scripts中指定应用的模式的方式有个小问题：在Windows上它不能工作。我们可以通过安装<a href="https://www.npmjs.com/package/cross-env">cross-env</a>包作为开发依赖更正这一问题：</p><pre><code class="shell">npm install cross-env</code></pre><p>使用方法：</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;cross-env NODE_ENV=production node index.js&quot;,    &quot;dev&quot;: &quot;cross-env NODE_ENV=development nodemon index.js&quot;,    &quot;test&quot;: &quot;cross-env NODE_ENV=test jest --verbose --runInBand&quot;,  &#125;,&#125;</code></pre><p>现在我们可以对定义应用配置的模块(<em>config.js</em>)做一点改变：</p><pre><code class="js">require(&#39;dotenv&#39;).config()const PORT = process.env.PORTconst MONGODB_URI = process.env.NODE_ENV === &#39;test&#39;   ? process.env.TEST_MONGODB_URI  : process.env.MONGODB_URImodule.exports = &#123;  MONGODB_URI,  PORT,&#125;</code></pre><p><em>.env</em>文件对开发和测试有不同的变量：</p><pre><code>MONGODB_URI=mongodb+srv://fullstack:&lt;password&gt;@cluster0.o1opl.mongodb.net/noteApp?retryWrites=true&amp;w=majorityPORT=3001TEST_MONGODB_URI=mongodb+srv://fullstack:&lt;password&gt;@cluster0.o1opl.mongodb.net/testNoteApp?retryWrites=true&amp;w=majority</code></pre><h4 id="supertest"><a href="#supertest" class="headerlink" title="supertest"></a>supertest</h4><p>使用<a href="https://github.com/visionmedia/supertest">supertest</a>包来帮助我们写测试API的测试。</p><p>将这个包安装成开发依赖：</p><pre><code class="shell">npm install --save-dev supertest</code></pre><p><em>tests&#x2F;note_api.test.js</em>:</p><pre><code class="js">const mongoose = require(&#39;mongoose&#39;)const supertest = require(&#39;supertest&#39;)const app = require(&#39;../app&#39;)//注意这里引入app而不是index.js，因为supertest保证被测试的应用运行在一个暂时的端口const api = supertest(app)//api =&gt; superagent对象test(&#39;notes are returned as json&#39;, async () =&gt; &#123;  await api    .get(&#39;/api/notes&#39;)    .expect(200)    .expect(&#39;Content-Type&#39;, /application\/json/)&#125;)test(&#39;there are two notes&#39;, async () =&gt; &#123;  const response = await api.get(&#39;/api/notes&#39;)  expect(response.body).toHaveLength(2)&#125;)test(&#39;the first note is about HTTP methods&#39;, async () =&gt; &#123;  const response = await api.get(&#39;/api/notes&#39;)  expect(response.body[0].content).toBe(&#39;HTML is easy&#39;)&#125;)afterAll(async () =&gt; &#123;  await mongoose.connection.close()&#125;)</code></pre><p>输出关于HTTP请求的信息的中间件会让测试执行的输出变得杂乱，让我们修改logger以让它在测试模式不输出信息到终端：</p><pre><code class="js">const info = (...params) =&gt; &#123;  if (process.env.NODE_ENV !== &#39;test&#39;) &#123;     console.log(...params)  &#125;&#125;const error = (...params) =&gt; &#123;  if (process.env.NODE_ENV !== &#39;test&#39;) &#123;     console.error(...params)  &#125;&#125;module.exports = &#123;  info, error&#125;</code></pre><h4 id="在测试前初始化数据库"><a href="#在测试前初始化数据库" class="headerlink" title="在测试前初始化数据库"></a>在测试前初始化数据库</h4><p>让我们使用<a href="https://jestjs.io/docs/en/api.html#beforeeachfn-timeout">beforeEach</a>方法在每一次测试前初始化数据库：</p><pre><code class="js">const mongoose = require(&#39;mongoose&#39;)const supertest = require(&#39;supertest&#39;)const app = require(&#39;../app&#39;)const api = supertest(app)const Note = require(&#39;../models/note&#39;)const initialNotes = [  &#123;    content: &#39;HTML is easy&#39;,    important: false,  &#125;,  &#123;    content: &#39;Browser can execute only JavaScript&#39;,    important: true,  &#125;,]beforeEach(async () =&gt; &#123;  await Note.deleteMany(&#123;&#125;)  let noteObject = new Note(initialNotes[0])  await noteObject.save()  noteObject = new Note(initialNotes[1])  await noteObject.save()&#125;)// ...</code></pre><h4 id="让测试一个接一个的执行"><a href="#让测试一个接一个的执行" class="headerlink" title="让测试一个接一个的执行"></a>让测试一个接一个的执行</h4><p><code>npm test</code>命令会执行所有测试，为了一次只测试一个或两个功能，一个好的主意是在<code>npm test</code>命令后用参数指明要执行的测试：</p><pre><code class="shell">npm test -- tests/note_api.test.js</code></pre><p><code>-t</code>选项可以用来执行特定名字的测试：</p><pre><code class="shell">npm test -- -t &quot;a specific note is within the returned notes&quot;npm test -- -t &#39;notes&#39; //名称包含notes的测试都会被执行</code></pre><h4 id="async-x2F-await"><a href="#async-x2F-await" class="headerlink" title="async&#x2F;await"></a>async&#x2F;await</h4><p>async&#x2F;await在ES7引入，可以让返回promise的异步函数在使用时可以以一种看起来像同步代码的方式:</p><pre><code class="js">Note.find(&#123;&#125;)  .then(notes =&gt; &#123;    return notes[0].deleteOne()  &#125;)  .then(response =&gt; &#123;    console.log(&#39;the first note is removed&#39;)    // more code here  &#125;)</code></pre><p>&#x3D;&#x3D;&#x3D;&gt;</p><pre><code class="js">const notes = await Note.find(&#123;&#125;)const response = await notes[0].deleteOne()console.log(&#39;the first note is removed&#39;)</code></pre><p>await关键字并不是可以随处使用的，await只能在<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async</a>函数中使用。</p><h4 id="async-x2F-await错误处理"><a href="#async-x2F-await错误处理" class="headerlink" title="async&#x2F;await错误处理"></a>async&#x2F;await错误处理</h4><p>对于async&#x2F;await推荐的异常处理方式是陈旧但让人熟悉的<em>try&#x2F;catch</em>机制：</p><pre><code class="js">notesRouter.post(&#39;/&#39;, async (request, response, next) =&gt; &#123;  const body = request.body  const note = new Note(&#123;    content: body.content,    important: body.important || false,  &#125;)  try &#123;    const savedNote = await note.save()    response.status(201).json(savedNote)  &#125; catch(exception) &#123;    next(exception)  &#125;&#125;)</code></pre><h4 id="优化beforeEach函数"><a href="#优化beforeEach函数" class="headerlink" title="优化beforeEach函数"></a>优化beforeEach函数</h4><pre><code class="js">beforeEach(async () =&gt; &#123;  await Note.deleteMany(&#123;&#125;);  let noteObject = new Note(helper.initialNotes[0]);  await noteObject.save();  noteObject = new Note(helper.initialNotes[1]);  await noteObject.save();&#125;);</code></pre><p>该函数保存<em>helper.initialNotes</em>数组中前两个note到数据库中。但是保存操作其实可以简化：</p><pre><code class="js">beforeEach(async () =&gt; &#123;  await Note.deleteMany(&#123;&#125;)  console.log(&#39;cleared&#39;)  helper.initialNotes.forEach(async (note) =&gt; &#123;    let noteObject = new Note(note)    await noteObject.save()    console.log(&#39;saved&#39;)  &#125;)  console.log(&#39;done&#39;)&#125;)</code></pre><p>但是这样的写法有严重的问题：forEach注册了多次async函数，beforeEach并不会等这些函数(即添加note的代码)结束再执行<code>console.log(&#39;saved&#39;)</code>，所以可能在beforeEach执行结束，下一次函数开始执行之后note们都还没被保存到数据库。</p><p>解决办法之一是使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all</a>方法：</p><pre><code class="js">beforeEach(async () =&gt; &#123;  await Note.deleteMany(&#123;&#125;)  const noteObjects = helper.initialNotes    .map(note =&gt; new Note(note))  const promiseArray = noteObjects.map(note =&gt; note.save())  await Promise.all(promiseArray)&#125;)</code></pre><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">Promise.all</a>并行执行它接收到的所有promise，所以如果这些promise的执行顺序需要固定，Promise.all可能不再适用。像这样的情况可以让操作在<em>for…of</em>块中执行，这样可以保证特定的顺序：</p><pre><code class="js">beforeEach(async () =&gt; &#123;  await Note.deleteMany(&#123;&#125;)  for (let note of helper.initialNotes) &#123;    let noteObject = new Note(note)    await noteObject.save()  &#125;&#125;)</code></pre><h3 id="c-用户管理"><a href="#c-用户管理" class="headerlink" title="c. 用户管理"></a>c. 用户管理</h3><p>如果我们使用关系数据库的话，每一个note会包含一个<strong>引用键</strong>用于引用创建它的用户。在文档数据库中我们可以做相同的事。</p><p>在note这个示例项目中我们将用户创建的note的id存到用户的文档中。让我们在models&#x2F;user.js文件中定义表示用户的模型：</p><pre><code class="js">const mongoose = require(&#39;mongoose&#39;)const userSchema = new mongoose.Schema(&#123;  username: String,  name: String,  passwordHash: String,  notes: [    &#123;      type: mongoose.Schema.Types.ObjectId,      ref: &#39;Note&#39;//Mongo实际上不知道这是一个引用note的字段，这个语法完全是由mongoose定义的。    &#125;  ],&#125;)userSchema.set(&#39;toJSON&#39;, &#123;  transform: (document, returnedObject) =&gt; &#123;    returnedObject.id = returnedObject._id.toString()    delete returnedObject._id    delete returnedObject.__v    // the passwordHash should not be revealed    delete returnedObject.passwordHash  &#125;&#125;)const User = mongoose.model(&#39;User&#39;, userSchema)module.exports = User</code></pre><p>扩展我们的note模式来让note包含创建它的用户的信息：</p><pre><code class="js">const noteSchema = new mongoose.Schema(&#123;  content: &#123;    type: String,    required: true,    minlength: 5  &#125;,  important: Boolean,  user: &#123;    type: mongoose.Schema.Types.ObjectId,    ref: &#39;User&#39;  &#125;&#125;)</code></pre><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><p>密码哈希字段是将单向哈希函数应用到用户密码后的输出，存储明文密码到数据库绝对不合适。</p><p>让我们安装<a href="https://github.com/kelektiv/node.bcrypt.js">bcrypt</a>包用来生成密码哈希：</p><pre><code class="shell">npm install bcrypt</code></pre><p>定义单独的路由器用来处理关于user的请求，文件命名为<em>controllers&#x2F;users.js</em>：</p><pre><code class="js">const bcrypt = require(&#39;bcrypt&#39;)const usersRouter = require(&#39;express&#39;).Router()const User = require(&#39;../models/user&#39;)usersRouter.post(&#39;/&#39;, async (request, response) =&gt; &#123;  const &#123; username, name, password &#125; = request.body  const saltRounds = 10  const passwordHash = await bcrypt.hash(password, saltRounds)  const user = new User(&#123;    username,    name,    passwordHash,  &#125;)  const savedUser = await user.save()  response.status(201).json(savedUser)&#125;)module.exports = usersRouter</code></pre><p>记得在app中引入这个路由器：</p><pre><code class="js">const usersRouter = require(&#39;./controllers/users&#39;)// ...app.use(&#39;/api/users&#39;, usersRouter)</code></pre><p>测试代码省略。</p><p>Mongoose没有内置的用于验证字段唯一性的验证器。可以使用<a href="https://www.npmjs.com/package/mongoose-unique-validator">mongoose-unique-validator</a>库。首先安装它：</p><pre><code class="shell">npm install mongoose-unique-validator</code></pre><p>然后扩展我们的代码：</p><pre><code class="js">const mongoose = require(&#39;mongoose&#39;)const uniqueValidator = require(&#39;mongoose-unique-validator&#39;)const userSchema = mongoose.Schema(&#123;  username: &#123;    type: String,    required: true,    unique: true //注意这个对象属性！！！  &#125;,  name: String,  passwordHash: String,  notes: [    &#123;      type: mongoose.Schema.Types.ObjectId,      ref: &#39;Note&#39;    &#125;  ],&#125;)userSchema.plugin(uniqueValidator)</code></pre><h4 id="创建新note"><a href="#创建新note" class="headerlink" title="创建新note"></a>创建新note</h4><p>因为我们在应用层引入了依赖关系，即新创建的note要被赋给创建它的用户。让我们扩展我们的实现：</p><pre><code class="js">const User = require(&#39;../models/user&#39;)//...notesRouter.post(&#39;/&#39;, async (request, response) =&gt; &#123;  const body = request.body  const user = await User.findById(body.userId)  const note = new Note(&#123;    content: body.content,    important: body.important === undefined ? false : body.important,    user: user.id  &#125;)  const savedNote = await note.save()  user.notes = user.notes.concat(savedNote._id)  await user.save()    response.json(savedNote)&#125;)</code></pre><h4 id="Populate"><a href="#Populate" class="headerlink" title="Populate"></a>Populate</h4><p>Mongoose可以实现类似关系数据库中连接查询的功能，Mongoose通过多次查询完成这样的功能，这与关系数据库中连接查询的事务性不同，事务性意味着查询在执行时数据库的状态不会改变。而使用Mongoose中的连接查询就不能保证被连接的集的状态是一致的。</p><p>Mongoose连接使用<a href="http://mongoosejs.com/docs/populate.html">populate</a>方法完成：</p><pre><code class="js">usersRouter.get(&#39;/&#39;, async (request, response) =&gt; &#123;  const users = await User    .find(&#123;&#125;).populate(&#39;notes&#39;)  response.json(users)&#125;)</code></pre><p>我们还可以在populate时选择我们想要的字段：</p><pre><code class="js">usersRouter.get(&#39;/&#39;, async (request, response) =&gt; &#123;  const users = await User    .find(&#123;&#125;).populate(&#39;notes&#39;, &#123; content: 1, important: 1 &#125;)  response.json(users)&#125;)</code></pre><p>理解这一点很重要：数据库并不知道存储在notes的user字段的id引用user集中的文档。</p><p>Mongoose的<em>populate</em>方法的功能是基于这样一个事实：我们在Mongoose模式中用ref选项定义了引用类型：</p><pre><code class="js">const noteSchema = new mongoose.Schema(&#123;  content: &#123;    type: String,    required: true,    minlength: 5  &#125;,  important: Boolean,  user: &#123;    type: mongoose.Schema.Types.ObjectId,    ref: &#39;User&#39;  &#125;&#125;)</code></pre><h3 id="d-Token认证"><a href="#d-Token认证" class="headerlink" title="d. Token认证"></a>d. Token认证</h3><p>现在要为后端实现<a href="https://www.digitalocean.com/community/tutorials/the-ins-and-outs-of-token-based-authentication#how-token-based-works">基于token的认证</a>，可以用一张序列图来描绘基于token认证的规则：</p><p><img src="/..%5Cimages%5CFullstack%5Cpart4%5C%E5%9F%BA%E4%BA%8Etoken%E8%AE%A4%E8%AF%81%E5%BA%8F%E5%88%97%E5%9B%BE.png" alt="基于token认证序列图"></p><p>首先实现登入功能。安装<a href="https://github.com/auth0/node-jsonwebtoken">jsonwebtoken</a>库，用来生成<a href="https://jwt.io/">JSON web tokens</a>：</p><pre><code class="shell">npm install jsonwebtoken</code></pre><p>登陆功能的代码放在controllers&#x2F;login.js中：</p><pre><code class="js">const jwt = require(&#39;jsonwebtoken&#39;)const bcrypt = require(&#39;bcrypt&#39;)const loginRouter = require(&#39;express&#39;).Router()const User = require(&#39;../models/user&#39;)loginRouter.post(&#39;/&#39;, async (request, response) =&gt; &#123;  const &#123; username, password &#125; = request.body  const user = await User.findOne(&#123; username &#125;)  const passwordCorrect = user === null    ? false    : await bcrypt.compare(password, user.passwordHash)  if (!(user &amp;&amp; passwordCorrect)) &#123;    return response.status(401).json(&#123;      error: &#39;invalid username or password&#39;    &#125;)  &#125;  const userForToken = &#123;    username: user.username,    id: user._id,  &#125;  const token = jwt.sign(userForToken, process.env.SECRET)  response    .status(200)    .send(&#123; token, username: user.username, name: user.name &#125;)&#125;)module.exports = loginRouter</code></pre><h4 id="仅限已登入的用户创建新note"><a href="#仅限已登入的用户创建新note" class="headerlink" title="仅限已登入的用户创建新note"></a>仅限已登入的用户创建新note</h4><p>有几种从浏览器发送token到服务器的方法，这里我们使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization">Authorization</a>头部，该头部也指明使用了哪一种 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#Authentication_schemes">认证模式</a>。</p><p><em>Bearer</em>模式适合我们的需求。</p><p>在实践中这意味着如果token是字符串<code>eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW</code>，认证头部的值将是：</p><pre><code>Bearer eyJhbGciOiJIUzI1NiIsInR5c2VybmFtZSI6Im1sdXVra2FpIiwiaW</code></pre><p>创建新note的代码需要改变一下：</p><pre><code class="js">const jwt = require(&#39;jsonwebtoken&#39;)// ...const getTokenFrom = request =&gt; &#123;  const authorization = request.get(&#39;authorization&#39;)  if (authorization &amp;&amp; authorization.startsWith(&#39;Bearer &#39;)) &#123;    return authorization.replace(&#39;Bearer &#39;, &#39;&#39;)  &#125;  return null&#125;notesRouter.post(&#39;/&#39;, async (request, response) =&gt; &#123;  const body = request.body  const decodedToken = jwt.verify(getTokenFrom(request), process.env.SECRET)  if (!decodedToken.id) &#123;    return response.status(401).json(&#123; error: &#39;token invalid&#39; &#125;)  &#125;  const user = await User.findById(decodedToken.id)  const note = new Note(&#123;    content: body.content,    important: body.important === undefined ? false : body.important,    user: user._id  &#125;)  const savedNote = await note.save()  user.notes = user.notes.concat(savedNote._id)  await user.save()  response.json(savedNote)&#125;)</code></pre><p>如果token不存在或者token无效，异常<em>JsonWebTokenError</em>被抛出。我们需要扩展错误处理中间件：</p><pre><code class="js">if (error.name ===  &#39;JsonWebTokenError&#39;) &#123;    return response.status(401).json(&#123; error: error.message &#125;)&#125;</code></pre><h4 id="基于token认证的问题"><a href="#基于token认证的问题" class="headerlink" title="基于token认证的问题"></a>基于token认证的问题</h4><p>token认证实现起来非常简单，但是它有一个问题。一旦API使用者，例如一个React App获得一个token，API会对token持有者盲目地信任。如果token持有者的访问权限应该被撤销呢？</p><p>解决该问题的方法有两种，简单的一种是限制一个token的有效期：</p><pre><code class="js">loginRouter.post(&#39;/&#39;, async (request, response) =&gt; &#123;  // other code  // token expires in 60*60 seconds, that is, in one hour  const token = jwt.sign(    userForToken,     process.env.SECRET,    &#123; expiresIn: 60*60 &#125;  )  // other code&#125;)</code></pre><p>这种也需要扩展我们的错误处理中间件：</p><pre><code class="js">if (error.name === &#39;TokenExpiredError&#39;) &#123;    return response.status(401).json(&#123;      error: &#39;token expired&#39;    &#125;)&#125;</code></pre><p>另一种解决方法是将每个token相关的信息存到后端数据库中，并且检验每一次API请求，看看是否与token对应的访问权限仍然有效。这种模式下访问权限可以随时被取消。这种解决方法通常被叫做服务端session。</p><h2 id="part5"><a href="#part5" class="headerlink" title="part5"></a>part5</h2><h3 id="a-前端登陆"><a href="#a-前端登陆" class="headerlink" title="a. 前端登陆"></a>a. 前端登陆</h3><h4 id="保存token到浏览器的local-storage"><a href="#保存token到浏览器的local-storage" class="headerlink" title="保存token到浏览器的local storage"></a>保存token到浏览器的local storage</h4><p>当前我们在前端登陆后，刷新页面将会清空登陆信息，需要重新登陆，这样肯定不合理。通过<a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage">local storage</a>可以很好地解决这个问题，Local Storage是位于浏览器中的<strong>键值对数据库</strong>。</p><p>local storage使用起来很简单：</p><pre><code class="js">window.localStorage.setItem(&#39;name&#39;, &#39;juha tauriainen&#39;) // 设置值window.localStorage.getItem(&#39;name&#39;) // 获取值window.localStorage.removeItem(&#39;name&#39;) // 移除值</code></pre><p>存储在storage中的值是<a href="https://docs.w3cub.com/dom/domstring">DOMstrings</a>。</p><h3 id="b-props-children-和-proptypes"><a href="#b-props-children-和-proptypes" class="headerlink" title="b. props.children 和 proptypes"></a>b. props.children 和 proptypes</h3><h4 id="组件孩子，即props-children"><a href="#组件孩子，即props-children" class="headerlink" title="组件孩子，即props.children"></a>组件孩子，即props.children</h4><p>与管理login表单可见性的代码可以考虑成是另外一个逻辑实体，由此将它们从App中分离成单独的组件是个不错的想法，我们的目标是实现一个Togglable组件，可以这样使用它：</p><pre><code class="jsx">&lt;Togglable buttonLabel=&#39;login&#39;&gt;  &lt;LoginForm    username=&#123;username&#125;    password=&#123;password&#125;    handleUsernameChange=&#123;(&#123; target &#125;) =&gt; setUsername(target.value)&#125;    handlePasswordChange=&#123;(&#123; target &#125;) =&gt; setPassword(target.value)&#125;    handleSubmit=&#123;handleLogin&#125;  /&gt;&lt;/Togglable&gt;</code></pre><p>用React术语来说，LoginForm是Togglable的<strong>子组件</strong>。</p><p><em>Togglable</em>组件的代码：</p><pre><code class="jsx">import &#123; useState &#125; from &#39;react&#39;const Togglable = (props) =&gt; &#123;  const [visible, setVisible] = useState(false)  const hideWhenVisible = &#123; display: visible ? &#39;none&#39; : &#39;&#39; &#125;  const showWhenVisible = &#123; display: visible ? &#39;&#39; : &#39;none&#39; &#125;  const toggleVisibility = () =&gt; &#123;    setVisible(!visible)  &#125;  return (    &lt;div&gt;      &lt;div style=&#123;hideWhenVisible&#125;&gt;        &lt;button onClick=&#123;toggleVisibility&#125;&gt;&#123;props.buttonLabel&#125;&lt;/button&gt;      &lt;/div&gt;      &lt;div style=&#123;showWhenVisible&#125;&gt;        &#123;props.children&#125;        &lt;button onClick=&#123;toggleVisibility&#125;&gt;cancel&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  )&#125;export default Togglable</code></pre><p><a href="https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children">props.children</a>用来引用组件的子组件。</p><h4 id="用ref来引用组件"><a href="#用ref来引用组件" class="headerlink" title="用ref来引用组件"></a>用ref来引用组件</h4><p>现在我们想让note表单在添加了一个note时被隐藏，但是由于控制note表单的可见性的逻辑位于Togglable中，我们如何才能在Togglable组件外访问它的状态呢？有许多可以实现这种功能的方法，这里介绍React的<a href="https://react.dev/learn/referencing-values-with-refs">ref</a>机制。</p><p>让我们对App组件做点改变：</p><pre><code class="jsx">import &#123; useState, useEffect, useRef &#125; from &#39;react&#39;const App = () =&gt; &#123;  // ...  const noteFormRef = useRef()  const noteForm = () =&gt; (    &lt;Togglable buttonLabel=&#39;new note&#39; ref=&#123;noteFormRef&#125;&gt;      &lt;NoteForm createNote=&#123;addNote&#125; /&gt;    &lt;/Togglable&gt;  )  // ...&#125;</code></pre><p><em>noteFormRef</em>变量对<em>Togglable</em>组件进行引用。useRef钩子保证在组件重新渲染过程中保存相同的引用。</p><p>接下来需要对<em>Togglable</em>组件进行改动：</p><pre><code class="jsx">import &#123; useState, forwardRef, useImperativeHandle &#125; from &#39;react&#39;const Togglable = forwardRef((props, refs) =&gt; &#123;  const [visible, setVisible] = useState(false)  const hideWhenVisible = &#123; display: visible ? &#39;none&#39; : &#39;&#39; &#125;  const showWhenVisible = &#123; display: visible ? &#39;&#39; : &#39;none&#39; &#125;  const toggleVisibility = () =&gt; &#123;    setVisible(!visible)  &#125;  useImperativeHandle(refs, () =&gt; &#123;    return &#123;      toggleVisibility    &#125;  &#125;)  return (    &lt;div&gt;      &lt;div style=&#123;hideWhenVisible&#125;&gt;        &lt;button onClick=&#123;toggleVisibility&#125;&gt;&#123;props.buttonLabel&#125;&lt;/button&gt;      &lt;/div&gt;      &lt;div style=&#123;showWhenVisible&#125;&gt;        &#123;props.children&#125;        &lt;button onClick=&#123;toggleVisibility&#125;&gt;cancel&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  )&#125;)export default Togglable</code></pre><p>创建组件的函数被包装在一次<a href="https://react.dev/reference/react/forwardRef">forwardRef</a>函数调用中，<strong>这样组件就能访问赋给它的ref</strong>。</p><p>组件使用<a href="https://react.dev/reference/react/useImperativeHandle">useImperativeHandle</a>钩子来让它的<em>toggleVisibility</em>函数在组件外可用。</p><p>现在我们可以通过调用*noteFormRef.current.toggleVisibility()*来在note被创建后隐藏note表单：</p><pre><code class="jsx">const App = () =&gt; &#123;  // ...  const addNote = (noteObject) =&gt; &#123;    noteFormRef.current.toggleVisibility()    noteService      .create(noteObject)      .then(returnedNote =&gt; &#123;             setNotes(notes.concat(returnedNote))      &#125;)  &#125;  // ...&#125;</code></pre><h4 id="proptypes"><a href="#proptypes" class="headerlink" title="proptypes"></a>proptypes</h4><p>对一个组件的props的要求可以用<a href="https://github.com/facebook/prop-types">prop-types</a>包来定义：</p><pre><code class="shell">npm install prop-types</code></pre><p>我们可以将<em>Togglable</em>的<em>buttonLabel</em> prop定义成一个强制要求的字符串类型的prop：</p><pre><code class="jsx">import PropTypes from &#39;prop-types&#39;const Togglable = React.forwardRef((props, ref) =&gt; &#123;  // ..&#125;)Togglable.propTypes = &#123;  buttonLabel: PropTypes.string.isRequired&#125;</code></pre><h4 id="ESlint"><a href="#ESlint" class="headerlink" title="ESlint"></a>ESlint</h4><p>接下来我们会开始测试前端，为了避免不希望出现的和无关的linter错误，我们安装<a href="https://www.npmjs.com/package/eslint-plugin-jest">eslint-plugin-jest</a>包：</p><pre><code class="shell">npm install --save-dev eslint-plugin-jest</code></pre><h3 id="c-测试React应用"><a href="#c-测试React应用" class="headerlink" title="c. 测试React应用"></a>c. 测试React应用</h3><p>测试React应用的方式有许多种，我们将来探讨一下。</p><p>我们先继续使用<a href="http://jestjs.io/">Jest</a>测试库来测试，除了Jest我们还需要另一个测试库用来帮助我们进行测试目的的渲染。当前的最佳选择是<a href="https://github.com/testing-library/react-testing-library">react-testing-library</a>。</p><p>安装几个库：</p><pre><code class="shell">npm install --save-dev @testing-library/react @testing-library/jest-dom jest-environment-jsdom @babel/preset-env @babel/preset-react</code></pre><p>文件package.json也需要扩展：</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    // ...    &quot;test&quot;: &quot;jest&quot;  &#125;  // ...  &quot;jest&quot;: &#123;    &quot;testEnvironment&quot;: &quot;jsdom&quot;  &#125;&#125;</code></pre><p>我们还需要文件*.babelrc*：</p><pre><code class="json">&#123;  &quot;presets&quot;: [    &quot;@babel/preset-env&quot;,    [&quot;@babel/preset-react&quot;, &#123; &quot;runtime&quot;: &quot;automatic&quot; &#125;]  ]&#125;</code></pre><p>让我们先来为负责渲染note的组件写测试：</p><pre><code class="jsx">const Note = (&#123; note, toggleImportance &#125;) =&gt; &#123;  const label = note.important    ? &#39;make not important&#39;    : &#39;make important&#39;  return (    &lt;li className=&#39;note&#39;&gt;      &#123;note.content&#125;      &lt;button onClick=&#123;toggleImportance&#125;&gt;&#123;label&#125;&lt;/button&gt;    &lt;/li&gt;  )&#125;</code></pre><p>注意li元素的属性className。</p><h4 id="渲染用于测试的组件"><a href="#渲染用于测试的组件" class="headerlink" title="渲染用于测试的组件"></a>渲染用于测试的组件</h4><p>我们将把我们的测试写在<em>src&#x2F;components&#x2F;Note.test.js</em>文件中，注意目录与组件的目录相同。</p><p>第一个测试验证组件渲染note的内容：</p><pre><code class="js">import React from &#39;react&#39;import &#39;@testing-library/jest-dom&#39;import &#123; render, screen &#125; from &#39;@testing-library/react&#39;import Note from &#39;./Note&#39;test(&#39;renders content&#39;, () =&gt; &#123;  const note = &#123;    content: &#39;Component testing is done with react-testing-library&#39;,    important: true  &#125;  render(&lt;Note note=&#123;note&#125; /&gt;)  const element = screen.getByText(&#39;Component testing is done with react-testing-library&#39;)  expect(element).toBeDefined()&#125;)</code></pre><p>render是react-testing-library提供的方法，会渲染一个组件。通常React组件被渲染到DOM。但是这里的render方法将组件渲染成一种适合测试的格式，不会把它们渲染到DOM。</p><p>我们可以用对象<a href="https://testing-library.com/docs/queries/about#screen">screen</a>来访问被渲染的对象。我们用screen的<a href="https://testing-library.com/docs/queries/bytext">getByText</a>来搜索有着对应内容的元素，并确保该元素存在。</p><h4 id="在一个组件中搜索内容"><a href="#在一个组件中搜索内容" class="headerlink" title="在一个组件中搜索内容"></a>在一个组件中搜索内容</h4><p>我们也可以通过使用render方法返回的字段之一——<a href="https://testing-library.com/docs/react-testing-library/api/#container-1">container</a>对象的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector">querySelector</a>方法来寻找被渲染的元素：</p><pre><code class="js">const &#123; container &#125; = render(&lt;Note note=&#123;note&#125; /&gt;)  const div = container.querySelector(&#39;.note&#39;)  expect(div).toHaveTextContent(    &#39;Component testing is done with react-testing-library&#39;  )</code></pre><h4 id="调试测试"><a href="#调试测试" class="headerlink" title="调试测试"></a>调试测试</h4><p>对象<em>screen</em>有<a href="https://testing-library.com/docs/queries/about/#screendebug">debug</a>方法可以被用来打印一个组件的HTML到终端，例如：</p><pre><code class="js">import React from &#39;react&#39;import &#39;@testing-library/jest-dom&#39;import &#123; render, screen &#125; from &#39;@testing-library/react&#39;import Note from &#39;./Note&#39;test(&#39;renders content&#39;, () =&gt; &#123;  const note = &#123;    content: &#39;Component testing is done with react-testing-library&#39;,    important: true  &#125;  render(&lt;Note note=&#123;note&#125; /&gt;)  screen.debug()  // ...&#125;)</code></pre><h4 id="在测试中点击按钮"><a href="#在测试中点击按钮" class="headerlink" title="在测试中点击按钮"></a>在测试中点击按钮</h4><p>让我们安装一个库<a href="https://testing-library.com/docs/user-event/intro">user-event</a>，该库让模拟用户输入变得更简单：</p><pre><code class="shell">npm install --save-dev @testing-library/user-event</code></pre><p>接下来可以测试note的切换importance功能：</p><pre><code class="js">import React from &#39;react&#39;import &#39;@testing-library/jest-dom&#39;import &#123; render, screen &#125; from &#39;@testing-library/react&#39;import userEvent from &#39;@testing-library/user-event&#39;import Note from &#39;./Note&#39;// ...test(&#39;clicking the button calls event handler once&#39;, async () =&gt; &#123;  const note = &#123;    content: &#39;Component testing is done with react-testing-library&#39;,    important: true  &#125;  const mockHandler = jest.fn()  render(    &lt;Note note=&#123;note&#125; toggleImportance=&#123;mockHandler&#125; /&gt;  )  const user = userEvent.setup()  const button = screen.getByText(&#39;make not important&#39;)  await user.click(button)  expect(mockHandler.mock.calls).toHaveLength(1)&#125;)</code></pre><p>有一些与测试有关的有趣的事情。</p><p>事件处理器是一个用Jest定义的<a href="https://facebook.github.io/jest/docs/en/mock-functions.html">mock</a>函数：</p><pre><code class="js">const mockHandler = jest.fn()</code></pre><p>一个<a href="https://testing-library.com/docs/user-event/setup/">session</a>启动以与被渲染的组件交互：</p><pre><code class="js">const user = userEvent.setup()</code></pre><p>我们写的测试基于来自被渲染的组件的文本寻找button，并且点击该元素：</p><pre><code class="js">const button = screen.getByText(&#39;make not important&#39;)await user.click(button)</code></pre><p>测试的expection验证<em>mock</em>函数只被调用一次：</p><pre><code class="js">expect(mockHandler.mock.calls).toHaveLength(1)</code></pre><h2 id="part-6"><a href="#part-6" class="headerlink" title="part 6"></a>part 6</h2><h3 id="a-Flux-架构-和-Redux"><a href="#a-Flux-架构-和-Redux" class="headerlink" title="a. Flux-架构 和 Redux"></a>a. Flux-架构 和 Redux</h3><h4 id="Flux架构"><a href="#Flux架构" class="headerlink" title="Flux架构"></a>Flux架构</h4><p>Facebook Flux架构:当一个action改变store的状态时，view被重新渲染</p><p><img src="/..%5Cimages%5CFullstack%5Cpart6%5Cflux1.png" alt="flux1"></p><h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><p>安装Redux：</p><pre><code class="shell">npm install redux</code></pre><p>Redux中状态被存储在<a href="https://redux.js.org/basics/store">store</a>中。</p><p>应用的全部状态存放在store中的一个JS对象中。状态通过action改变，action是至少有一个确定action类型的字段的对象。例如：</p><pre><code class="js">&#123;  type: &#39;INCREMENT&#39;&#125;</code></pre><p>action对应用状态的影响通过<a href="https://redux.js.org/basics/reducers">reducer</a>来定义，在实践中，一个reducer是一个函数，函数被给定当前的应用状态和一个action作为参数，函数返回一个新的状态。定义reducer：</p><pre><code class="js">const counterReducer = (state = 0, action) =&gt; &#123;  switch (action.type) &#123;    case &#39;INCREMENT&#39;:      return state + 1    case &#39;DECREMENT&#39;:      return state - 1    case &#39;ZERO&#39;:      return 0    default: // if none of the above matches, code comes here      return state  &#125;&#125;</code></pre><p>Reducer不支持也不应该在应用程序代码中直接调用，Reducer只是当做参数传给创建store的<em>createStore</em>函数：</p><pre><code class="js">import &#123; createStore &#125; from &#39;redux&#39;const counterReducer = (state = 0, action) =&gt; &#123;  // ...&#125;const store = createStore(counterReducer)</code></pre><p>现在store使用counterReducer来处理行为(使用<a href="https://redux.js.org/api/store#dispatchaction">dispatch</a>方法将action’调度’或者说’发送’给store):</p><pre><code class="js">store.dispatch(&#123; type: &#39;INCREMENT&#39; &#125;)</code></pre><p>通过 <a href="https://redux.js.org/api/store#getstate">getState</a>获取store的状态：</p><pre><code class="js">const store = createStore(counterReducer)console.log(store.getState())store.dispatch(&#123; type: &#39;INCREMENT&#39; &#125;)store.dispatch(&#123; type: &#39;INCREMENT&#39; &#125;)store.dispatch(&#123; type: &#39;INCREMENT&#39; &#125;)console.log(store.getState())store.dispatch(&#123; type: &#39;ZERO&#39; &#125;)store.dispatch(&#123; type: &#39;DECREMENT&#39; &#125;)console.log(store.getState())</code></pre><p>store拥有的第三个重要的方法是<a href="https://redux.js.org/api/store#subscribelistener">subscribe</a>，被用来创建回调函数，回调函数由store在每次一个action被调度给store的时候调用。例如：</p><pre><code class="js">store.subscribe(() =&gt; &#123;  const storeNow = store.getState()  console.log(storeNow)&#125;)</code></pre><p> <a href="https://reactjs.org/docs/uncontrolled-components.html">uncontrolled</a></p><h4 id="Action创建器"><a href="#Action创建器" class="headerlink" title="Action创建器"></a>Action创建器</h4><p>创建action的函数叫<a href="https://redux.js.org/tutorials/fundamentals/part-7-standard-patterns#action-creators">action creators</a>：</p><pre><code class="js">const createNote = (content) =&gt; &#123;  return &#123;    type: &#39;NEW_NOTE&#39;,    payload: &#123;      content,      important: false,      id: generateId()    &#125;  &#125;&#125;const toggleImportanceOf = (id) =&gt; &#123;  return &#123;    type: &#39;TOGGLE_IMPORTANCE&#39;,    payload: &#123; id &#125;  &#125;&#125;</code></pre><h4 id="将Redux存储-store-转发给不同的组件"><a href="#将Redux存储-store-转发给不同的组件" class="headerlink" title="将Redux存储(store)转发给不同的组件"></a>将Redux存储(store)转发给不同的组件</h4><pre><code class="js">// main.jsximport React from &#39;react&#39;import ReactDOM from &#39;react-dom/client&#39;import &#123; createStore &#125; from &#39;redux&#39;import &#123; Provider &#125; from &#39;react-redux&#39;import App from &#39;./App&#39;import noteReducer from &#39;./reducers/noteReducer&#39;const store = createStore(noteReducer)ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;)</code></pre><p>普通export使用：</p><pre><code class="js">import &#123; createNote &#125; from &#39;./../reducers/noteReducer&#39;</code></pre><p>默认export使用：</p><pre><code class="js">import noteReducer from &#39;./reducers/noteReducer&#39;</code></pre><p>修改App.jsx:</p><pre><code class="jsx">import &#123; createNote, toggleImportanceOf &#125; from &#39;./reducers/noteReducer&#39;import &#123; useSelector, useDispatch &#125; from &#39;react-redux&#39;const App = () =&gt; &#123;  const dispatch = useDispatch()  const notes = useSelector(state =&gt; state)  const addNote = (event) =&gt; &#123;    event.preventDefault()    const content = event.target.note.value    event.target.note.value = &#39;&#39;    dispatch(createNote(content))  &#125;  const toggleImportance = (id) =&gt; &#123;    dispatch(toggleImportanceOf(id))  &#125;  return (    &lt;div&gt;      &lt;form onSubmit=&#123;addNote&#125;&gt;        &lt;input name=&quot;note&quot; /&gt;         &lt;button type=&quot;submit&quot;&gt;add&lt;/button&gt;      &lt;/form&gt;      &lt;ul&gt;        &#123;notes.map(note =&gt;          &lt;li            key=&#123;note.id&#125;             onClick=&#123;() =&gt; toggleImportance(note.id)&#125;          &gt;            &#123;note.content&#125; &lt;strong&gt;&#123;note.important ? &#39;important&#39; : &#39;&#39;&#125;&lt;/strong&gt;          &lt;/li&gt;        )&#125;      &lt;/ul&gt;    &lt;/div&gt;  )&#125;export default App</code></pre><ul><li><p>dispatch现在通过<a href="https://react-redux.js.org/api/hooks#usedispatch">useDispatch</a>来进行。</p></li><li><p>组件可以通过<a href="https://react-redux.js.org/api/hooks#useselector">useSelector</a>来访问存储在store中的notes，还可以选择具有某种特性的状态。</p><pre><code class="jsx">const importantNotes = useSelector(state =&gt; state.filter(note =&gt; note.important))  </code></pre></li></ul><h4 id="更多组件"><a href="#更多组件" class="headerlink" title="更多组件"></a>更多组件</h4><p>我们来将创建新note的逻辑放到一个组件中：</p><pre><code class="jsx">import &#123; useDispatch &#125; from &#39;react-redux&#39;import &#123; createNote &#125; from &#39;../reducers/noteReducer&#39;const NewNote = () =&gt; &#123;  const dispatch = useDispatch()  const addNote = (event) =&gt; &#123;    event.preventDefault()    const content = event.target.note.value    event.target.note.value = &#39;&#39;    dispatch(createNote(content))  &#125;  return (    &lt;form onSubmit=&#123;addNote&#125;&gt;      &lt;input name=&quot;note&quot; /&gt;      &lt;button type=&quot;submit&quot;&gt;add&lt;/button&gt;    &lt;/form&gt;  )&#125;export default NewNote</code></pre><p><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">container</a>和<a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">presentational</a>。</p><h3 id="b-大量的reducer"><a href="#b-大量的reducer" class="headerlink" title="b. 大量的reducer"></a>b. 大量的reducer</h3><h4 id="带复杂状态的store"><a href="#带复杂状态的store" class="headerlink" title="带复杂状态的store"></a>带复杂状态的store</h4><p><a href="https://redux.js.org/api/combinereducers">combineReducers</a>函数。</p><h4 id="Redux-Toolkit"><a href="#Redux-Toolkit" class="headerlink" title="Redux Toolkit"></a>Redux Toolkit</h4><p>安装：</p><pre><code class="shell">npm install @reduxjs/toolkit</code></pre><p>使用<a href="https://redux-toolkit.js.org/api/configureStore">configureStore</a>函数：</p><pre><code class="js">import React from &#39;react&#39;import ReactDOM from &#39;react-dom/client&#39;import &#123; Provider &#125; from &#39;react-redux&#39;import &#123; configureStore &#125; from &#39;@reduxjs/toolkit&#39;import App from &#39;./App&#39;import noteReducer from &#39;./reducers/noteReducer&#39;import filterReducer from &#39;./reducers/filterReducer&#39;const store = configureStore(&#123;  reducer: &#123;    notes: noteReducer,    filter: filterReducer  &#125;&#125;)console.log(store.getState())ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(  &lt;Provider store=&#123;store&#125;&gt;    &lt;App /&gt;  &lt;/Provider&gt;)</code></pre><p>使用<a href="https://redux-toolkit.js.org/api/createSlice">createSlice</a>创建action和action创建器：</p><pre><code class="js">import &#123; createSlice &#125; from &#39;@reduxjs/toolkit&#39;const initialState = [  &#123;    content: &#39;reducer defines how redux store works&#39;,    important: true,    id: 1,  &#125;,  &#123;    content: &#39;state of store can contain any data&#39;,    important: false,    id: 2,  &#125;,]const generateId = () =&gt;  Number((Math.random() * 1000000).toFixed(0))const noteSlice = createSlice(&#123;  name: &#39;notes&#39;,  initialState,  reducers: &#123;    createNote(state, action) &#123;      const content = action.payload      state.push(&#123;        content,        important: false,        id: generateId(),      &#125;)    &#125;,    toggleImportanceOf(state, action) &#123;      const id = action.payload      const noteToChange = state.find(n =&gt; n.id === id)      const changedNote = &#123;         ...noteToChange,         important: !noteToChange.important       &#125;      return state.map(note =&gt;        note.id !== id ? note : changedNote       )         &#125;  &#125;,&#125;)</code></pre><p>Redux Toolkit利用<a href="https://immerjs.github.io/immer/">Immer</a>库来处理<em>createSlice</em>函数创建的reducer，可以在reducer中修改state参数。</p><p>export：</p><pre><code class="js">const noteSlice = createSlice(/* ... */)export const &#123; createNote, toggleImportanceOf &#125; = noteSlice.actionsexport default noteSlice.reducer</code></pre><h4 id="Redux-Toolkit-和-console-log"><a href="#Redux-Toolkit-和-console-log" class="headerlink" title="Redux Toolkit 和 console.log"></a>Redux Toolkit 和 console.log</h4><p>console.log(JSON.parse(JSON.stringify(state)))</p><h3 id="c-在redux应用中与服务器通信"><a href="#c-在redux应用中与服务器通信" class="headerlink" title="c. 在redux应用中与服务器通信"></a>c. 在redux应用中与服务器通信</h3><h4 id="从后端获取数据"><a href="#从后端获取数据" class="headerlink" title="从后端获取数据"></a>从后端获取数据</h4><h3 id="d-React查询，useReducer和context"><a href="#d-React查询，useReducer和context" class="headerlink" title="d. React查询，useReducer和context"></a>d. React查询，useReducer和context</h3><h4 id="用React-Query库在服务器上管理数据"><a href="#用React-Query库在服务器上管理数据" class="headerlink" title="用React Query库在服务器上管理数据"></a>用React Query库在服务器上管理数据</h4><p>安装React Query:</p><pre><code class="shell">npm install @tanstack/react-query</code></pre><h2 id="part7"><a href="#part7" class="headerlink" title="part7"></a>part7</h2><h3 id="a-React-Router"><a href="#a-React-Router" class="headerlink" title="a. React Router"></a>a. React Router</h3><h4 id="应用导航栏结构"><a href="#应用导航栏结构" class="headerlink" title="应用导航栏结构"></a>应用导航栏结构</h4><p>简单示例：</p><pre><code class="jsx">import &#123; useState &#125;  from &#39;react&#39;import ReactDOM from &#39;react-dom/client&#39;const Home = () =&gt; (  &lt;div&gt; &lt;h2&gt;TKTL notes app&lt;/h2&gt; &lt;/div&gt;)const Notes = () =&gt; (  &lt;div&gt; &lt;h2&gt;Notes&lt;/h2&gt; &lt;/div&gt;)const Users = () =&gt; (  &lt;div&gt; &lt;h2&gt;Users&lt;/h2&gt; &lt;/div&gt;)const App = () =&gt; &#123;  const [page, setPage] = useState(&#39;home&#39;)  const toPage = (page) =&gt; (event) =&gt; &#123;    event.preventDefault()    setPage(page)  &#125;  const content = () =&gt; &#123;    if (page === &#39;home&#39;) &#123;      return &lt;Home /&gt;    &#125; else if (page === &#39;notes&#39;) &#123;      return &lt;Notes /&gt;    &#125; else if (page === &#39;users&#39;) &#123;      return &lt;Users /&gt;    &#125;  &#125;  const padding = &#123;    padding: 5  &#125;  return (    &lt;div&gt;      &lt;div&gt;        &lt;a href=&quot;&quot; onClick=&#123;toPage(&#39;home&#39;)&#125; style=&#123;padding&#125;&gt;          home        &lt;/a&gt;        &lt;a href=&quot;&quot; onClick=&#123;toPage(&#39;notes&#39;)&#125; style=&#123;padding&#125;&gt;          notes        &lt;/a&gt;        &lt;a href=&quot;&quot; onClick=&#123;toPage(&#39;users&#39;)&#125; style=&#123;padding&#125;&gt;          users        &lt;/a&gt;      &lt;/div&gt;      &#123;content()&#125;    &lt;/div&gt;  )&#125;ReactDOM.createRoot(document.getElementById(&#39;root&#39;)).render(&lt;App /&gt;)</code></pre><h4 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h4><p>安装：</p><pre><code class="shell">npm install react-router-dom</code></pre><p>使用：</p><pre><code class="jsx">import &#123;  BrowserRouter as Router,  Routes, Route, Link&#125; from &#39;react-router-dom&#39;const App = () =&gt; &#123;  const padding = &#123;    padding: 5  &#125;  return (    &lt;Router&gt;      &lt;div&gt;        &lt;Link style=&#123;padding&#125; to=&quot;/&quot;&gt;home&lt;/Link&gt;        &lt;Link style=&#123;padding&#125; to=&quot;/notes&quot;&gt;notes&lt;/Link&gt;        &lt;Link style=&#123;padding&#125; to=&quot;/users&quot;&gt;users&lt;/Link&gt;      &lt;/div&gt;      &lt;Routes&gt;        &lt;Route path=&quot;/notes&quot; element=&#123;&lt;Notes /&gt;&#125; /&gt;        &lt;Route path=&quot;/users&quot; element=&#123;&lt;Users /&gt;&#125; /&gt;        &lt;Route path=&quot;/&quot; element=&#123;&lt;Home /&gt;&#125; /&gt;      &lt;/Routes&gt;      &lt;div&gt;        &lt;i&gt;Note app, Department of Computer Science 2023&lt;/i&gt;      &lt;/div&gt;    &lt;/Router&gt;  )&#125;</code></pre><p>路由，或者说基于浏览器URL的组件条件渲染，通过将组件放在Router组件中实现。</p><h4 id="useNavigate"><a href="#useNavigate" class="headerlink" title="useNavigate"></a>useNavigate</h4><pre><code class="jsx">const Login = (props) =&gt; &#123;  const navigate = useNavigate()  const onSubmit = (event) =&gt; &#123;    event.preventDefault()    props.onLogin(&#39;mluukkai&#39;)    navigate(&#39;/&#39;) //使用  &#125;//...&#125;</code></pre><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><pre><code class="jsx">&lt;Route path=&quot;/users&quot; element=&#123;user ? &lt;Users /&gt; : &lt;Navigate replace to=&quot;/login&quot; /&gt;&#125; /&gt;</code></pre><h4 id="再谈参数化路由"><a href="#再谈参数化路由" class="headerlink" title="再谈参数化路由"></a>再谈参数化路由</h4><pre><code class="jsx">import &#123;  // ...  useMatch&#125; from &#39;react-router-dom&#39;const App = () =&gt; &#123;  // ...  const match = useMatch(&#39;/notes/:id&#39;)  const note = match     ? notes.find(note =&gt; note.id === Number(match.params.id))    : null  return (      &lt;Routes&gt;          //...        &lt;Route path=&quot;/notes/:id&quot; element=&#123;&lt;Note note=&#123;note&#125; /&gt;&#125; /&gt;          //...      &lt;/Routes&gt;    &lt;/div&gt;  )&#125;  </code></pre><p>每一次组件被重新渲染时，在实践中基本上是指浏览器URL改变时，下面的命令被执行：</p><pre><code class="jsx">const match = useMatch(&#39;/notes/:id&#39;)</code></pre><p>如果URL匹配*&#x2F;notes&#x2F;:id*，match变量将会包含一个对象，从该对象中我们可以访问路径的参数化部分，即要被显示的note的id。</p><h3 id="b-自定义钩子"><a href="#b-自定义钩子" class="headerlink" title="b. 自定义钩子"></a>b. 自定义钩子</h3><h4 id="钩子"><a href="#钩子" class="headerlink" title="钩子"></a>钩子</h4><p>React提供15个不同的<a href="https://react.dev/reference/react">内置钩子</a>。</p><p>准则：</p><ul><li><strong>Don’t call Hooks inside loops, conditions, or nested functions.</strong></li><li><strong>Don’t call Hooks from regular JavaScript functions.</strong></li></ul><h4 id="自定义钩子"><a href="#自定义钩子" class="headerlink" title="自定义钩子"></a>自定义钩子</h4><p><a href="https://react.dev/learn/reusing-logic-with-custom-hooks">custom</a></p><p>自定义useCounter：</p><pre><code class="js">const useCounter = () =&gt; &#123;  const [value, setValue] = useState(0)  const increase = () =&gt; &#123;    setValue(value + 1)  &#125;  const decrease = () =&gt; &#123;    setValue(value - 1)  &#125;  const zero = () =&gt; &#123;    setValue(0)  &#125;  return &#123;    value,     increase,    decrease,    zero  &#125;&#125;</code></pre><h4 id="传播属性"><a href="#传播属性" class="headerlink" title="传播属性"></a>传播属性</h4><p>下面两种传递props的方式可以达到相同的效果：</p><pre><code class="jsx">&lt;Greeting firstName=&#39;Arto&#39; lastName=&#39;Hellas&#39; /&gt;const person = &#123;  firstName: &#39;Arto&#39;,  lastName: &#39;Hellas&#39;&#125;&lt;Greeting &#123;...person&#125; /&gt;</code></pre><p>resources:</p><ul><li><a href="https://github.com/rehooks/awesome-react-hooks">Awesome React Hooks Resources</a></li><li><a href="https://usehooks.com/">Easy to understand React Hook recipes by Gabe Ragland</a></li><li><a href="https://overreacted.io/why-do-hooks-rely-on-call-order/">Why Do React Hooks Rely on Call Order?</a></li></ul><h3 id="c-更多关于样式的知识"><a href="#c-更多关于样式的知识" class="headerlink" title="c. 更多关于样式的知识"></a>c. 更多关于样式的知识</h3><h3 id="d-Webpack"><a href="#d-Webpack" class="headerlink" title="d. Webpack"></a>d. Webpack</h3><p>webpack是最为人熟知的bundler，但是最近几年出现了一些新的bundler，例如vite所使用的esbuild。</p><h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><p>老旧的浏览器不知道如何处理模块化的代码（因为模块是ES6引进的），因此被分成多个模块的代码需要被转换成单个文件，该文件包含所有程序代码。</p><p>例如之前打包的简单的程序结构：</p><pre><code>├── assets│   ├── index-d526a0c5.css│   ├── index-e92ae01e.js│   └── react-35ef61ed.svg├── index.html└── vite.svg</code></pre><p>index.html -&gt; 主文件，用script标签加载打包的JS代码：</p><pre><code class="html">&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;title&gt;Vite + React&lt;/title&gt;    &lt;script type=&quot;module&quot; crossorigin src=&quot;/assets/index-e92ae01e.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/index-d526a0c5.css&quot;&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;      &lt;/body&gt;&lt;/html&gt;</code></pre><p><em>webpack.config.js</em>中定义webpack的功能：</p><pre><code class="js">const path = require(&#39;path&#39;)const config = () =&gt; &#123;  return &#123;    entry: &#39;./src/index.js&#39;,    output: &#123;      path: path.resolve(__dirname, &#39;build&#39;),      filename: &#39;main.js&#39;    &#125;  &#125;&#125;module.exports = config</code></pre><p>定义npm脚本：</p><pre><code class="json">&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;webpack --mode=development&quot;&#125;,</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置文件(webpack.config.js)用JS书写并且返回配置对象的函数用Node的模块语法导出。</p><h4 id="打包React，加载器"><a href="#打包React，加载器" class="headerlink" title="打包React，加载器"></a>打包React，加载器</h4><p>默认情况下webpack只知道如何处理普通JS，我们可以使用 <a href="https://webpack.js.org/concepts/loaders/">loaders</a> 来通知webpack我们的JSX文件在打包前需要被处理。</p><p>为我们的应用配置一个将JSX转成JS的加载器：</p><pre><code class="js">const path = require(&#39;path&#39;)const config = () =&gt; &#123;  return &#123;    entry: &#39;./src/index.js&#39;,    output: &#123;      path: path.resolve(__dirname, &#39;build&#39;),      filename: &#39;main.js&#39;    &#125;,    module: &#123;      rules: [        &#123;          test: /\.js$/,          loader: &#39;babel-loader&#39;,          options: &#123;            presets: [&#39;@babel/preset-react&#39;],          &#125;,        &#125;,      ],    &#125;,  &#125;&#125;module.exports = config</code></pre><p>一个加载器由三个部分组成：</p><pre><code class="js">&#123;  test: /\.js$/,  loader: &#39;babel-loader&#39;,  options: &#123;    presets: [&#39;@babel/preset-react&#39;]  &#125;&#125;</code></pre><p>现在可以成功打包。</p><p>注意如果程序源代码使用了<em>async&#x2F;await</em>，有些浏览器将不会渲染任何东西。可能需要安装两个依赖：</p><pre><code class="shell">npm install core-js regenerator-runtime</code></pre><p>并且在index.js文件顶部引入依赖：</p><pre><code class="js">import &#39;core-js/stable/index.js&#39;import &#39;regenerator-runtime/runtime.js&#39;</code></pre><h4 id="转译器"><a href="#转译器" class="headerlink" title="转译器"></a>转译器</h4><p>大多数浏览器不支持ES6&#x2F;ES7语法，所以需要转译。当前最流行的转译器是Babel。Babel执行的转译过程是以插件形式定义的。当前我们使用<a href="https://babeljs.io/docs/plugins/preset-react/">@babel&#x2F;preset-react</a>预设来转译我们程序的源代码：</p><pre><code class="js">&#123;  test: /\.js$/,  loader: &#39;babel-loader&#39;,  options: &#123;    presets: [&#39;@babel/preset-react&#39;]  &#125;&#125;</code></pre><p>让我们添加<a href="https://babeljs.io/docs/plugins/preset-env/">@babel&#x2F;preset-env</a>插件，插件包含所有用来将使用最新特性的代码转译成与ES5标准兼容的代码：</p><pre><code class="js">&#123;  test: /\.js$/,  loader: &#39;babel-loader&#39;,  options: &#123;    presets: [&#39;@babel/preset-env&#39;, &#39;@babel/preset-react&#39;]  &#125;&#125;</code></pre><p>注意要安装该预设：</p><pre><code class="shell">npm install @babel/preset-env --save-dev</code></pre><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><p>给应用添加一点CSS，并且在App.js中使用：</p><pre><code class="css">.container &#123;  margin: 10px;  background-color: #dee8e4;&#125;</code></pre><p>再次打包会失败：当使用CSS时我们必须使用<a href="https://webpack.js.org/loaders/css-loader/">css</a>和 <a href="https://webpack.js.org/loaders/style-loader/">style</a>加载器：</p><pre><code class="js">&#123;  rules: [    &#123;      test: /\.js$/,      loader: &#39;babel-loader&#39;,      options: &#123;        presets: [&#39;@babel/preset-react&#39;, &#39;@babel/preset-env&#39;],      &#125;,    &#125;,    &#123;      test: /\.css$/,      use: [&#39;style-loader&#39;, &#39;css-loader&#39;],    &#125;,  ];&#125;</code></pre><p>并且安装加载器：</p><pre><code class="shell">npm install style-loader css-loader --save-dev</code></pre><p>之后可以正常打包。</p><h4 id="Webpack-dev-server"><a href="#Webpack-dev-server" class="headerlink" title="Webpack-dev-server"></a>Webpack-dev-server</h4><p>当前我们的工作流很麻烦，可以用<a href="https://webpack.js.org/guides/development/#using-webpack-dev-server">webpack-dev-server</a>来解决我们的问题：</p><pre><code class="shell">npm install --save-dev webpack-dev-server</code></pre><p>定义npm脚本来启动dev服务器：</p><pre><code class="json">&quot;start&quot;: &quot;webpack serve --mode=development&quot;</code></pre><p>并且在<em>webpack.config.js</em>的配置对象中添加新属性<em>devServer</em>:</p><pre><code class="js">const config = &#123;  entry: &#39;./src/index.js&#39;,  output: &#123;    path: path.resolve(__dirname, &#39;build&#39;),    filename: &#39;main.js&#39;,  &#125;,  devServer: &#123;    static: path.resolve(__dirname, &#39;build&#39;),    compress: true,    port: 3000,  &#125;,  // ...&#125;;</code></pre><p>现在执行npm run start后，可以在浏览器通过localhost:3000访问devServer，此时代码可以不用每次都打包。</p><h4 id="缩小代码"><a href="#缩小代码" class="headerlink" title="缩小代码"></a>缩小代码</h4><p>既是我们的程序只包含几行代码，main.js文件的大小也是1009487字节，因为打包过程也打包了整个React库的源代码。</p><p>对JS文件的优化过程叫做缩小化(<em>minification</em>)，一个领先的工具叫<a href="http://lisperator.net/uglifyjs/">UglifyJS</a>。从webpack版本4开始，minification插件不需要额外安装。只需要修改npm脚本来指定webpack以生产模式执行代码的打包工作：</p><pre><code class="json">&quot;build&quot;: &quot;webpack --mode=production&quot;,</code></pre><h4 id="开发和生产配置"><a href="#开发和生产配置" class="headerlink" title="开发和生产配置"></a>开发和生产配置</h4><h2 id="to-do"><a href="#to-do" class="headerlink" title="to do"></a>to do</h2><h3 id="exer"><a href="#exer" class="headerlink" title="exer"></a>exer</h3><p>4.6 4.7</p><p>4.20…</p><h2 id="工具-x2F-库整理"><a href="#工具-x2F-库整理" class="headerlink" title="工具&#x2F;库整理"></a>工具&#x2F;库整理</h2><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><ul><li><p>express</p></li><li><p>mongoose</p></li><li><p>mongoose-unique-validator</p></li><li><p>morgan</p></li><li><p>cors</p></li><li><p>nodemon</p></li><li><p>express-async-errors</p></li><li><p>bcrypt</p></li><li><p>jsonwebtoken</p></li><li><p>express-jwt</p></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>@testing-library&#x2F;react @testing-library&#x2F;jest-dom jest-environment-jsdom @babel&#x2F;preset-env @babel&#x2F;preset-react</li><li>@testing-library&#x2F;user-event</li><li>deep-freeze</li><li>prop-types</li><li>redux、react-redux、redux-toolkit</li><li><a href="https://github.com/reduxjs/redux-thunk">Redux Thunk</a></li><li><a href="https://tanstack.com/query/latest">React Query</a> </li><li>React Router</li><li>React Boostrap</li><li>material UI</li><li><a href="https://www.styled-components.com/">styled components</a></li><li><a href="https://www.npmjs.com/package/lodash">lodash</a>、<a href="https://ramdajs.com/">ramda</a></li></ul><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><ul><li>cross-env</li><li>dotenv</li><li>jest</li><li>eslint-plugin-jest</li><li>supertest, superagent</li><li>webpack</li><li>webpack-dev-server</li></ul><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><ul><li><p>json-server</p></li><li><p>eslint软件&#x2F;eslint插件</p></li><li><p>REST Client</p></li><li><p>React Devtools</p></li><li><p>Redux DevTools</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;课程网址：&lt;a href=&quot;https://fullstackopen.com/en/&quot;&gt;https://fullstackopen.com</summary>
      
    
    
    
    
    <category term="web开发" scheme="http://example.com/tags/web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>记一次关于TreeMap的使用的坑</title>
    <link href="http://example.com/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/"/>
    <id>http://example.com/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/</id>
    <published>2023-06-09T06:56:42.089Z</published>
    <updated>2023-06-09T07:27:13.922Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做《牛客算法必刷101》的最后一题时遇到了一个坑。原题目这里就不赘述了，原题目地址：</p><p><a href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&tqId=1006014&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&amp;tqId=1006014&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj</a></p><p>定义<code>TreeMap&lt;int[], Integer&gt; orderedMap </code>,要求orderedMap（下文简称map）的键长度为3，并且给出map的完整定义：</p><pre><code class="java">private TreeMap&lt;int[], Integer&gt; orderedMap = new TreeMap&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;    @Override    public int compare(int[] a, int[] b) &#123;        //如果调用次数不等，次数少的排在前面        if (a[1] != b[1])            return a[1] - b[1];        //如果调用次数相等，调用时间早的排在前面        return a[2] - b[2];    &#125;&#125;);</code></pre><p>这里我想表达的是：对于map中的两个键，如果一个键的第二个元素小于另一个键的第二个元素，那么这个键排在另一个键的前面；如果这两个键相等，那么键的第三个元素小的排前面。</p><p>现在假设map中现有几个元素</p><pre><code class="java">[1, 1, 0] -&gt;  1[4, 2, 4] -&gt;  4[3, 2, 5] -&gt;  3[2, 2, 6] -&gt;  2</code></pre><p>可以看到现在map中元素的顺序是正确的，如果我用一个变量data记录了map中的第一个键，就像这样（实际我的代码中是通过其它方式获得这个键的，这里为了简洁就直接从map中获得了）：</p><pre><code class="java">int[] data = orderedMap.firstKey();</code></pre><p>现在如果我通过data修改数组为[1,2,7]：</p><pre><code class="java">data[1] = 2;data[2] = 7;</code></pre><p>然后我将data从map中删除，然后再将data添加到map中不就可以保持map中的元素有序了吗？</p><pre><code class="java">orderedMap.remove(data);orderedMap.put(data, key);//这里key是map中data还没被删除时对应的值</code></pre><p>然而是我太天真了，这样做<code>orderedMap.remove(data)</code> 返回的居然是null。这就奇了怪了，我的data明明是存在map中的啊，怎么删除data会返回null呢？也就是说怎么会找不到**[1,2,7]**呢？print调试找不出错误了，只好将代码粘贴到idea中进行调试。下面是方法调用过程：</p><pre><code class="java">public V remove(Object key) &#123;    Entry&lt;K,V&gt; p = getEntry(key);    if (p == null)        return null;    V oldValue = p.value;    deleteEntry(p);    return oldValue;&#125;</code></pre><p>remove方法会先调用getEntry方法：</p><pre><code class="java">final Entry&lt;K,V&gt; getEntry(Object key) &#123;    // Offload comparator-based version for sake of performance        if (comparator != null)        return getEntryUsingComparator(key);        /*    下面的代码不用看    if (key == null)        throw new NullPointerException();    @SuppressWarnings(&quot;unchecked&quot;)    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;    Entry&lt;K,V&gt; p = root;    while (p != null) &#123;        int cmp = k.compareTo(p.key);        if (cmp &lt; 0)            p = p.left;        else if (cmp &gt; 0)            p = p.right;        else            return p;    &#125;    return null;*/&#125;</code></pre><p>这里comparator是在定义map时传入的，不为空，所以会进入getEntryUsingComparator这个方法：</p><pre><code class="java">final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;    @SuppressWarnings(&quot;unchecked&quot;)    K k = (K) key;    Comparator&lt;? super K&gt; cpr = comparator;    if (cpr != null) &#123;        Entry&lt;K,V&gt; p = root;        while (p != null) &#123;            int cmp = cpr.compare(k, p.key);            if (cmp &lt; 0)                p = p.left;            else if (cmp &gt; 0)                p = p.right;            else                return p;        &#125;    &#125;    return null;&#125;</code></pre><p>重点在if语句，由于TreeMap是基于红黑树的数据结构，<strong>查找的时候不会遍历每一个元素</strong>，而是<strong>从根节点开始查找</strong>，如果<code>compare(k, p.key)</code> 返回0，就可以将p返回；如果返回值小于0，则在树的左半边查找；如果返回值大于0，则在树的右半边查找。</p><p>看到这里我们大致知道为什么<code>orderedMap.remove(data)</code> 返回null了：一开始data在红黑树的某个位置x，修改data中的数据后，我们查找data就是在树中<strong>查找新的data应该在的位置</strong>，但是我们通过data修改map中的一个键，并不会让树重新有序（remove后再put就是想让树保持有序），也就是说data所在的位置是错误的。在map中找不到data当然通过data删除也就不行了。</p><p>如何完成正确重新排序呢？答案是先将data从map中移除（因为这个时候还没修改data中的数据，是可以从map中正确删除data的），通过data修改数据后再将data添加到map中。</p><pre><code class="java">orderedMap.remove(data);data[1] = 2;data[2] = 7;orderedMap.put(data, key);//这里key是map中data还没被删除时对应的值</code></pre><p>这样map中的数据将会是有序的（还记得排序规则吗：键的第二个元素相同时，第三个元素小的排前面，所以[1,2,7]在最后）：</p><pre><code class="java">[4, 2, 4] -&gt;  4[3, 2, 5] -&gt;  3[2, 2, 6] -&gt;  2[1, 2, 7] -&gt;  1</code></pre><p>总结：如果修改TreeMap中的键并且想保持有序，需要先移除键，在修改操作完成后再将键存入TreeMap！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天在做《牛客算法必刷101》的最后一题时遇到了一个坑。原题目这里就不赘述了，原题目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在Java中，0.4被传入System.out.print时发生了什么？</title>
    <link href="http://example.com/2023/06/09/%E5%9C%A8Java%E4%B8%AD%EF%BC%8C0.4%E8%A2%AB%E4%BC%A0%E5%85%A5System.out.print%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2023/06/09/%E5%9C%A8Java%E4%B8%AD%EF%BC%8C0.4%E8%A2%AB%E4%BC%A0%E5%85%A5System.out.print%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2023-06-09T06:55:14.609Z</published>
    <updated>2023-06-09T07:27:58.227Z</updated>
    
    <content type="html"><![CDATA[<p>在看JavaGuide复习Java基础知识的时候，看到了浮点数表示的章节。突然想知道，为什么0.4明明不能被准确表示，但是在传入System.out.println时显示到控制台的却是0.4呢？</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4    &#125;&#125;</code></pre><p>在继续阅读之前，我希望你能够具备一定的前置知识：</p><ul><li>了解浮点数是如何在计算机中表示的</li><li>了解不是所有实数都能被准确表示</li><li>0.4就是不能被准确表示的数之一</li><li>了解BigDecimal类</li></ul><p>我们可以通过BigDecimal类和System.out.println（以下简称print）来打印一个double的实际值：</p><pre><code class="java">import java.math.BigDecimal;public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4        System.out.println(new BigDecimal(d1));//打印结果：0.40000000000000002220446049250313080847263336181640625    &#125;&#125;</code></pre><p>通过上面的代码和其运行结果可以看出，当0.4被当做double字面量时，其真实值其实是0.40000000000000002220446049250313080847263336181640625。那print打印d1的时候不应该显示0.40000000000000002220446049250313080847263336181640625吗？</p><p>那为什么将d1传入print却得到0.4呢？首先我们进行一个猜想：是不是在定义变量d1时，其对应的字面量（即在写代码的时候直接写在代码中的0.4）被虚拟机记录成这样的形式(d1 –&gt; “0.4”)，然后在将double传入print时，print在虚拟机中找到d1对应的”0.4”然后打印”0.4”？这样好像是可行的，但是会有一些问题，例如：不是所有的double变量都是通过字面量直接定义的，如果这样定义d1<code> double d1 = 0.2 * 2</code> 虚拟机就不能获取”d1 –&gt;0.4”这样的信息了。难道虚拟机会记录(d1 –&gt; “0.2 * 2”)，然后在打印时打印0.2 * 2到屏幕上吗？显然不合理。那么print到底是怎么做的呢？</p><p>像0.40000000000000002220446049250313080847263336181640625这样一个值可以表示一个范围内的实数，例如从</p><pre><code class="java">import java.math.BigDecimal;public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        double d2 = 0.400000000000000000001;                System.out.println(d1);//0.4        System.out.println(d2);//0.4                System.out.println(new BigDecimal(d1));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d2));//0.40000000000000002220446049250313080847263336181640625    &#125;&#125;</code></pre><p>这个代码段可以看出0.4和0.400000000000000000001其实用的是同一个真实值来表示，即0.40000000000000002220446049250313080847263336181640625的表示范围中包含了0.4和0.400000000000000000001。<br>而double传入print时，虚拟机会调用Double.toString(double d)这个方法来将double转成一个String。而Double.toString(double d)这个方法会将参数d转换成它范围内的有效位最少的数字。例如，假设0.40000000000000002220446049250313080847263336181640625表示范围为[0.40000000000000002220446049250313080847263336181640625 - x, 0.40000000000000002220446049250313080847263336181640625 + y]，那么落在这个范围的数字通过toString转换都变成了”0.4”。而0.4000001和0.40000010000000001都落到0.400000100000000025080026944124256260693073272705078125这个数字的表示范围，通过toString转换都会变成0.4000001。</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        double d2 = 0.400000000000000000001;        double d3 = 0.4000001;        double d4 = 0.40000010000000001;                System.out.println(d1);//0.4        System.out.println(d2);//0.4        System.out.println(d3);//0.4000001        System.out.println(d4);//0.4000001                System.out.println(new BigDecimal(d1));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d2));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d3));//0.400000100000000025080026944124256260693073272705078125        System.out.println(new BigDecimal(d4));//0.400000100000000025080026944124256260693073272705078125            &#125;&#125;</code></pre><p>总结一下：</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4    &#125;&#125;</code></pre><p>这段程序可以看做经历了几个阶段：</p><ul><li>定义d1，d1的真实值为0.40000000000000002220446049250313080847263336181640625</li><li>d1被Double.toString(double)方法转换成”0.4”</li><li>“0.4”被打印到屏幕上</li></ul><p>参考:</p><ul><li><a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">https://stackoverflow.com/questions/588004/is-floating-point-math-broken</a></li><li><a href="https://stackoverflow.com/questions/22526897/how-does-java-precisely-display-a-double-while-it-cannot-be-accurately-expressed">https://stackoverflow.com/questions/22526897/how-does-java-precisely-display-a-double-while-it-cannot-be-accurately-expressed</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html">https://docs.oracle.com/javase/8/docs/api/index.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在看JavaGuide复习Java基础知识的时候，看到了浮点数表示的章节。突然想知道，为什么0.4明明不能被准确表示，但是在传入System.out.println时显示到控制台的却是0.4呢？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;public clas</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="计算机基础" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>牛客在线编程之Java语法</title>
    <link href="http://example.com/2023/06/09/%E7%89%9B%E5%AE%A2%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2023/06/09/%E7%89%9B%E5%AE%A2%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E8%AF%AD%E6%B3%95/</id>
    <published>2023-06-09T06:47:14.049Z</published>
    <updated>2023-06-09T07:27:37.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="牛客Java语法篇"><a href="#牛客Java语法篇" class="headerlink" title="牛客Java语法篇"></a>牛客Java语法篇</h1><p>这些题大体都没什么难度，做这些题的目的是为了熟悉Java类库。<br>绝大部分题都是直接贴上答案，但是少部分题的某些知识有所遗忘，我也会将我的学习过程写到对应题目处。</p><h2 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h2><pre><code class="java">public static int typeConversion(double d)&#123;    //write your code here......    return (int) d;&#125;</code></pre><h2 id="2-简单运算"><a href="#2-简单运算" class="headerlink" title="2. 简单运算"></a>2. 简单运算</h2><pre><code class="java">int bigger = a &gt; b ? a : b;int smaller = a;if (bigger == a)    smaller = b;System.out.print(bigger + smaller);System.out.print(&quot; &quot;);System.out.print(bigger - smaller);System.out.print(&quot; &quot;);System.out.print(bigger * smaller);System.out.print(&quot; &quot;);System.out.print(bigger / smaller);System.out.print(&quot; &quot;);System.out.print(bigger % smaller);System.out.print(&quot; &quot;);</code></pre><h2 id="3-四舍五入"><a href="#3-四舍五入" class="headerlink" title="3. 四舍五入"></a>3. 四舍五入</h2><p>由于题目要求将double四舍五入为int，所以用Math.round方法。</p><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double d = scanner.nextDouble();        //write your code here......        int i = (int)Math.round(d);        System.out.println(i);    &#125;&#125;</code></pre><h2 id="4-交换变量值"><a href="#4-交换变量值" class="headerlink" title="4. 交换变量值"></a>4. 交换变量值</h2><p>为了方便注释，统一假设a、b原来的值为A,B</p><ul><li><p>方法1</p><pre><code class="java">a = a + b;// a = A + Bb = a - b;// b = A + B - B = Aa = a - b;// a = A + B - A = B</code></pre></li><li><p>方法2</p><pre><code class="java">a = a ^ b;// a = A ^ Bb = a ^ b;// b = A ^ B ^ B = Aa = a ^ b;// a = A ^ B ^ A = B</code></pre><p>理解这种做法首先要知道:</p><ul><li>A ^ A &#x3D; 0</li><li>0 ^ A &#x3D; A</li></ul></li></ul><p>上面这两种方法都是用其中一个变量保存两个变量的状态，就好像是让两个变量的值共存与一个变量(a + b、a ^ b）。然后通过某种运算从两种状态的变量提取出其中的某一个状态。</p><ul><li><p>方法3</p><pre><code class="java">i = j + (j = i) * 0;</code></pre></li></ul><p>这种方法利用了0*A &#x3D; 0,0 + A &#x3D; A，还有在Java中如果一个赋值号右边发生了赋值，右边的变量进行运算时还是使用原来的值。在其它语言中这种方法不一定适用。</p><h2 id="5-计算商场折扣"><a href="#5-计算商场折扣" class="headerlink" title="5. 计算商场折扣"></a>5. 计算商场折扣</h2><pre><code class="java">import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner console = new Scanner(System.in);        int price = console.nextInt();        int cost = price;        //write your code here......        if (price &gt;= 5000) &#123;            cost = (int) (price * 0.6);        &#125; else if (price &gt;= 2000) &#123;            cost = (int) (price * 0.7);        &#125; else if (price &gt;= 500) &#123;            cost = (int) (price * 0.8);        &#125; else if (price &gt;= 100) &#123;            cost = (int) (price * 0.9);        &#125;        System.out.println(cost);    &#125;&#125;</code></pre><h2 id="6-判断体重指数"><a href="#6-判断体重指数" class="headerlink" title="6. 判断体重指数"></a>6. 判断体重指数</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double height = scanner.nextDouble();        double weight = scanner.nextDouble();        //write your code here......        double index = weight / (height * height);        if (index &lt; 18.5) &#123;            System.out.print(&quot;偏瘦&quot;);        &#125; else if (index &lt; 20.9) &#123;            System.out.print(&quot;苗条&quot;);        &#125; else if (index &lt; 24.9) &#123;            System.out.print(&quot;适中&quot;);        &#125; else &#123;            System.out.print(&quot;偏胖&quot;);        &#125;    &#125;&#125;</code></pre><h2 id="7-判断学生成绩等级"><a href="#7-判断学生成绩等级" class="headerlink" title="7. 判断学生成绩等级"></a>7. 判断学生成绩等级</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String grade =scanner.next();        //write your code here......        if (grade == null) &#123;            System.out.print(&quot;未知等级&quot;);            return;        &#125;        if (grade.equals(&quot;A&quot;)) &#123;            System.out.print(&quot;优秀&quot;);        &#125; else if (grade.equals(&quot;B&quot;)) &#123;            System.out.print(&quot;良好&quot;);        &#125; else if (grade.equals(&quot;C&quot;)) &#123;            System.out.print(&quot;及格&quot;);        &#125; else if (grade.equals(&quot;D&quot;)) &#123;            System.out.print(&quot;不及格&quot;);        &#125; else &#123;            System.out.print(&quot;未知等级&quot;);        &#125;    &#125;&#125;</code></pre><h2 id="8-邮箱验证"><a href="#8-邮箱验证" class="headerlink" title="8. 邮箱验证"></a>8. 邮箱验证</h2><pre><code class="java">import java.util.Scanner;import java.util.regex.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.next();        String emailMatcher=&quot;[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+&quot;;        //write your code here......        boolean isEmail = Pattern.matches(emailMatcher, str);        if (isEmail) &#123;            System.out.print(&quot;邮箱格式合法&quot;);        &#125; else &#123;            System.out.print(&quot;邮箱格式不合法&quot;);        &#125;    &#125;&#125;</code></pre><p>Java正则表达式</p><p><a href="https://www.runoob.com/java/java-regular-expressions.html">https://www.runoob.com/java/java-regular-expressions.html</a></p><ul><li><p>简介</p><ul><li><p>正则表达式定义了字符串的模式。</p></li><li><p>正则表达式可以用来搜索、编辑或处理文本。</p></li><li><p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p></li></ul></li><li><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p><strong>Pattern 类：</strong></p><p>pattern 对象是一个正则表达式的<strong>编译表示</strong>。Pattern 类<strong>没有公共构造方法</strong>。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p><strong>Matcher 类：</strong></p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p><strong>PatternSyntaxException：</strong></p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><p>实例</p><pre><code class="java">import java.util.regex.*; class RegexExample1&#123;   public static void main(String[] args)&#123;      String content = &quot;I am noob &quot; +        &quot;from runoob.com.&quot;;       String pattern = &quot;.*runoob.*&quot;;       boolean isMatch = Pattern.matches(pattern, content);      System.out.println(&quot;字符串中是否包含了 &#39;runoob&#39; 子字符串? &quot; + isMatch);//true   &#125;&#125;</code></pre></li></ul><h2 id="9-数列求和"><a href="#9-数列求和" class="headerlink" title="9. 数列求和"></a>9. 数列求和</h2><pre><code class="java">long num = 0;long sum = 0L;for (int i = 1; i &lt;= 10; i++) &#123;    num = num * 10L + 9L;    sum += num;&#125;System.out.print(sum);</code></pre><h2 id="10-统计输入正数个数"><a href="#10-统计输入正数个数" class="headerlink" title="10. 统计输入正数个数"></a>10. 统计输入正数个数</h2><pre><code class="java">int i = -1;int num;do &#123;    i++;    num = scanner.nextInt();&#125; while(num &gt; 0);System.out.print(i);scanner.close();</code></pre><h2 id="11-求最小公倍数"><a href="#11-求最小公倍数" class="headerlink" title="11. 求最小公倍数"></a>11. 求最小公倍数</h2><pre><code class="java">public static int getCM(int m, int n)&#123;    //write your code here......    int b = m &gt; n ? m : n;//大的那一个    int s = (b == m) ? n : m;//小的那一个    int result = b;    while (result%s != 0) &#123;        result += b;    &#125;    return result;&#125;</code></pre><h2 id="12-小球走过的路程计算"><a href="#12-小球走过的路程计算" class="headerlink" title="12. 小球走过的路程计算"></a>12. 小球走过的路程计算</h2><pre><code class="java">double total = 0;do &#123;    total += h;    h = h / 2.0f;    total += h;&#125; while (--n &gt; 0);total = total - h;//输出格式为：System.out.println(String.format(&quot;%.3f&quot;, h)+&quot; &quot;+String.format(&quot;%.3f&quot;, sum));System.out.println(String.format(&quot;%.3f&quot;, h)+&quot; &quot;+String.format(&quot;%.3f&quot;, total));</code></pre><h2 id="13-求平均数"><a href="#13-求平均数" class="headerlink" title="13. 求平均数"></a>13. 求平均数</h2><pre><code class="java">Long total = 0L;int num = 0;int nextInt = 0;while (scan.hasNextInt() &amp;&amp; (nextInt = scan.nextInt()) &gt;= 0) &#123;    total += nextInt;    num++;&#125;double avg = (double)total / num;System.out.println(String.format(&quot;%.2f&quot;, avg));</code></pre><h2 id="14-判断质数"><a href="#14-判断质数" class="headerlink" title="14. 判断质数"></a>14. 判断质数</h2><pre><code class="java">public Boolean isPrimeNumber(int number) &#123;    //write your code here......    int i = number / 2;    for (int j = i; j &gt; 1; j--) &#123;        if (number % j == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><h2 id="15-计算整数位数"><a href="#15-计算整数位数" class="headerlink" title="15. 计算整数位数"></a>15. 计算整数位数</h2><pre><code class="java">if (num &lt;= 0) &#123;    System.out.print(num);&#125; else &#123;    int n = 0;    while (num &gt; 0) &#123;        n++;        num /= 10;    &#125;    System.out.print(n);&#125;</code></pre><h2 id="16-数组遍历"><a href="#16-数组遍历" class="headerlink" title="16. 数组遍历"></a>16. 数组遍历</h2><pre><code class="java">max = Integer.MIN_VALUE;min = Integer.MAX_VALUE;for (int n: ary) &#123;    max = n &gt; max ? n : max;    min = n &lt; min ? n : min;&#125;</code></pre><h2 id="17-数组倒转"><a href="#17-数组倒转" class="headerlink" title="17. 数组倒转"></a>17. 数组倒转</h2><pre><code class="java">int temp;for (int i = 0; i &lt; arr.length / 2; i++) &#123;    temp = arr[i];    arr[i] = arr[arr.length - i - 1];    arr[arr.length - i - 1] = temp;&#125;</code></pre><h2 id="18-二维数组求和"><a href="#18-二维数组求和" class="headerlink" title="18. 二维数组求和"></a>18. 二维数组求和</h2><pre><code class="java">for (int i = 0; i &lt; arr.length; i++) &#123;    int[] rowArr = arr[i];    for (int j = 0; j &lt; rowArr.length; j++) &#123;        sum += rowArr[j];    &#125;&#125;</code></pre><h2 id="19-修改Data类的定义"><a href="#19-修改Data类的定义" class="headerlink" title="19. 修改Data类的定义"></a>19. 修改Data类的定义</h2><pre><code class="java">class Data &#123;    private int x;    private int y;        public Data(int x, int y) &#123;        this.x = x;        this.y = y;    &#125;    public int getX() &#123;        return x;    &#125;    public int getY() &#123;        return y;    &#125;&#125;</code></pre><h2 id="20-验证年龄"><a href="#20-验证年龄" class="headerlink" title="20. 验证年龄"></a>20. 验证年龄</h2><pre><code class="java">class Person &#123;    private int age;    //write your code here......    public void setAge(int age) &#123;        if (age &lt; 0) &#123;            this.age = 0;         &#125; else if (age &gt; 200) &#123;            this.age = 200;        &#125; else &#123;            this.age = age;        &#125;            &#125;    public int getAge() &#123;        return age;    &#125;&#125;</code></pre><h2 id="21-补全构造方法"><a href="#21-补全构造方法" class="headerlink" title="21. 补全构造方法"></a>21. 补全构造方法</h2><pre><code class="java">super(x, y);this.z = z;</code></pre><h2 id="22-重写计算逻辑"><a href="#22-重写计算逻辑" class="headerlink" title="22. 重写计算逻辑"></a>22. 重写计算逻辑</h2><p>这里遇到了一点小插曲。因为题目中没有说要写子类构造方法，我也就没注意，结果编译时报错了。</p><pre><code>Main.java:10: error: constructor Sub in class Sub cannot be applied to given types;Sub sub = new Sub(x, y);required: no argumentsfound: int,int</code></pre><p>大致意思就是我没有提供Sub(int,int)这样的构造函数。我看了一下，基类有构造函数Base(int x, int y)，我突然回忆不起默认构造函数在父类有构造函数时是怎样的情况了。于是到网上搜了一下，发现很多讲默认构造函数的文章都是一笔带过，没办法直接看Java Se 8 Specification吧。规范中给出了这样的示例：</p><p>下面的声明：</p><pre><code class="java">public class Point &#123;    int x, y;&#125;</code></pre><p>与这个声明相同：</p><pre><code class="java">public class Point &#123;    int x, y;    public Point() &#123; super(); &#125;&#125;</code></pre><p>所以父类如果没有无参构造函数，子类就不能使用默认构造函数了。（看到这个示例的时候又觉得自己的记忆中就是这样的情况，但是有时候脑子就是这样，看到答案时会觉得简单）</p><p>补齐构造函数：</p><pre><code class="java">class Sub extends Base &#123;    public Sub(int x, int y) &#123;        super(x, y);    &#125;    //write your code here......    @Override    public void calculate() &#123;        System.out.println(getY() == 0 ? &quot;Error&quot; : getX() / getY());    &#125;&#125;</code></pre><h2 id="23-定义打印方法"><a href="#23-定义打印方法" class="headerlink" title="23. 定义打印方法"></a>23. 定义打印方法</h2><pre><code class="java">private static void print(Object obj) &#123;    System.out.print(obj.toString());&#125;</code></pre><h2 id="24-类型判断"><a href="#24-类型判断" class="headerlink" title="24. 类型判断"></a>24. 类型判断</h2><pre><code class="java">public static String getClassName(Base obj) &#123;    //write your code here......    if (obj instanceof Sub2) &#123;        return &quot;Sub2&quot;;    &#125; else if (obj instanceof Sub1) &#123;        return &quot;Sub1&quot;;    &#125; else &#123;        return &quot;Base&quot;;    &#125;&#125;</code></pre><h2 id="25-实现抽象方法"><a href="#25-实现抽象方法" class="headerlink" title="25. 实现抽象方法"></a>25. 实现抽象方法</h2><pre><code class="java">class Sub extends Base &#123;    //write your code here......    @Override    public int sum() &#123;        return getX() + getY();    &#125;    @Override     public int avg() &#123;        return sum() / 2;    &#125;&#125;</code></pre><h2 id="26-实现接口"><a href="#26-实现接口" class="headerlink" title="26. 实现接口"></a>26. 实现接口</h2><pre><code class="java">class ComparatorImpl implements Comparator &#123;    @Override    public int max(int x, int y) &#123;        return x &gt; y ? x : y;    &#125;&#125;</code></pre><p>这里我以为接口方法在实现时不能加@Override，结果是可以的。看来@Override不止可以用于重写父类的方法。</p><p>SE8官方文档中这样写到：</p><p><strong>If a method declaration is annotated with the annotation</strong> <code>@Override</code><strong>, but the method does not override or implement a method declared in a supertype, or is not override-equivalent to a</strong> <code>public</code> <strong>method of</strong> <code>Object</code><strong>, a compile-time error occurs.</strong></p><p>翻译：如果一个方法声明用@Override进行注解，但是方法没有重写或者<strong>实现</strong>声明在超类型中方法，或者对Object的公共方法来说不是override-equivalent的，那么就会产生一个编译时错误。</p><p>看到这里已经可以解决上面的问题了：@Override可以用于实现接口方法声明的方法。</p><p>但是新的疑问又产生了：So what is override-equivalent?</p><p>首先给出我的答案来源：<a href="https://stackoverflow.com/questions/16207386/what-is-override-equivalence-and-how-is-it-related-to-override">https://stackoverflow.com/questions/16207386/what-is-override-equivalence-and-how-is-it-related-to-override</a></p><p>但是我没看楼主的答案，而是根据楼主的提示——官方文档中有解释——找到了答案。</p><p>The signature of a method <code>m1</code> is a <em>subsignature</em> of the signature of a method <code>m2</code> if either:</p><ul><li><code>m2</code> has the same signature as <code>m1</code>, or</li><li>the signature of <code>m1</code> is the same as the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6">§4.6</a>) of the signature of <code>m2</code>.</li></ul><p>Two method signatures <code>m1</code> and <code>m2</code> are <em>override-equivalent</em> iff either <code>m1</code> is a subsignature of <code>m2</code> or <code>m2</code> is a subsignature of <code>m1</code>.</p><p>大致意思是说：函数签名是override-equivalent的条件是m1是m2的子签名或者m2是m1的子签名。而如果方法m2的签名与方法m1的签名相同或者m1的签名与m2的签名的erasure相同，则可以说m1的子签名是m2的签名的子签名。</p><p>那什么又是erasure捏？（苦笑）</p><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6</a> 内容实在是有点多，如果有时间我会斗胆翻译一下，感兴趣的可以去看看。</p><h2 id="27-重写父类方法"><a href="#27-重写父类方法" class="headerlink" title="27. 重写父类方法"></a>27. 重写父类方法</h2><pre><code class="java">class Sub extends Base &#123;    public Sub(int x, int y) &#123;        super(x, y);    &#125;    //write your code here......    @Override    public int getX() &#123;        return super.getX() * 10;    &#125;&#125;</code></pre><h2 id="28-创建单例对象"><a href="#28-创建单例对象" class="headerlink" title="28. 创建单例对象"></a>28. 创建单例对象</h2><pre><code class="java">public static Singleton getInstance() &#123;    if (instance == null) &#123;        instance = new Singleton();    &#125;    return instance;&#125;</code></pre><h2 id="29-动态字符串"><a href="#29-动态字符串" class="headerlink" title="29. 动态字符串"></a>29. 动态字符串</h2><pre><code class="java">int len = str.length();int remainder = len % 3;int commas = len / 3 - 1;if (remainder != 0) &#123;    commas++;&#125;StringBuilder newStr = new StringBuilder(commas + len);for (int i  = 0; i &lt; len; i++) &#123;    newStr.append(str.charAt(i));    if ((i+1) % 3 == remainder &amp;&amp; i != len - 1) &#123;        newStr.append(&quot;,&quot;);    &#125;&#125;System.out.print(newStr);</code></pre><h2 id="30-统计字符串中字母出现次数"><a href="#30-统计字符串中字母出现次数" class="headerlink" title="30. 统计字符串中字母出现次数"></a>30. 统计字符串中字母出现次数</h2><pre><code class="java">public static int check(String str, String word) &#123;    //write your code here......    int times = 0;    int from = -1;    while (true) &#123;        from = str.indexOf(word, from + 1);        if (from == -1) &#123;            break;        &#125;        times++;    &#125;    return times;&#125;</code></pre><h2 id="31-十进制数转二进制数"><a href="#31-十进制数转二进制数" class="headerlink" title="31. 十进制数转二进制数"></a>31. 十进制数转二进制数</h2><pre><code class="java">//write your code here......StringBuilder strNum = new StringBuilder();while (num &gt; 0) &#123;    strNum.insert(0, num % 2);    num /= 2;&#125;//这里题目的输入描述其实说了输入的是正整数，但是测试用例里有0System.out.println(strNum.length() &gt; 0 ? strNum : 0);</code></pre><h2 id="33-掷骰子"><a href="#33-掷骰子" class="headerlink" title="33. 掷骰子"></a>33. 掷骰子</h2><pre><code class="java">System.out.print(random.nextInt(6) + 1);</code></pre><h2 id="34-求绝对值，平方根，对数，正弦值"><a href="#34-求绝对值，平方根，对数，正弦值" class="headerlink" title="34. 求绝对值，平方根，对数，正弦值"></a>34. 求绝对值，平方根，对数，正弦值</h2><pre><code class="java">System.out.println(Math.abs(num));System.out.println(Math.sqrt(num));System.out.println(Math.log(num));System.out.println(Math.sin(num));</code></pre><h2 id="35-输出某一年的各个月份的天数"><a href="#35-输出某一年的各个月份的天数" class="headerlink" title="35. 输出某一年的各个月份的天数"></a>35. 输出某一年的各个月份的天数</h2><p>没怎么用过Calendar这个类，感觉自己写得太麻烦了。</p><pre><code class="java">import java.util.Calendar;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner console = new Scanner(System.in);        int year = console.nextInt();        //write your code here......        Calendar cal = Calendar.getInstance();        cal.set(year, 0, 1);//Calendar类月份从0开始计！即0表示1月份。        int month = 1;//用于记录当前的月份        int countDay = 0;//用于记录一个月的天数        while (month &lt;= 12) &#123;            cal.add(Calendar.DAY_OF_MONTH, 1);            countDay++;            while (cal.get(Calendar.DAY_OF_MONTH) != 1) &#123;                cal.add(Calendar.DAY_OF_MONTH, 1);                countDay++;            &#125;                                    System.out.println(year + &quot;年&quot; + month + &quot;月:&quot; + countDay + &quot;天&quot;);            countDay = 0;            month++;        &#125;    &#125;&#125;</code></pre><h2 id="36-日期换算"><a href="#36-日期换算" class="headerlink" title="36. 日期换算"></a>36. 日期换算</h2><pre><code class="java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);Scanner in = new Scanner(System.in);String str1 = in.nextLine();//write your code here......String[] dateTimeStr = str1.split(&quot; &quot;);if (dateTimeStr.length &lt; 6) &#123;    System.out.print(&quot;您输入的数据不合理&quot;);    return;&#125;            int year = Integer.valueOf(dateTimeStr[0]);int month = Integer.valueOf(dateTimeStr[1]);int day = Integer.valueOf(dateTimeStr[2]);int hour = Integer.valueOf(dateTimeStr[3]);int minute = Integer.valueOf(dateTimeStr[4]);int second = Integer.valueOf(dateTimeStr[5]);     LocalDateTime dateTime = LocalDateTime.of(year, 1, 1, 0, 0, 0);dateTime = dateTime.plusMonths(month-1);dateTime = dateTime.plusDays(day-1);dateTime = dateTime.plusHours(hour);dateTime = dateTime.plusMinutes(minute);dateTime = dateTime.plusSeconds(second);System.out.println(&quot;北京时间为：&quot; + dateTime.format(dtf));dateTime = dateTime.minusHours(12);System.out.println(&quot;纽约时间为：&quot; + dateTime.format(dtf));</code></pre><h2 id="37-判断学生成绩"><a href="#37-判断学生成绩" class="headerlink" title="37. 判断学生成绩"></a>37. 判断学生成绩</h2><pre><code class="java">import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int score = scanner.nextInt();        //write your code here......        try &#123;            if (!(score &gt;= 0 &amp;&amp; score &lt;= 100)) &#123;                throw new ScoreException(&quot;分数不合法&quot;);            &#125;            System.out.println(score);        &#125; catch (ScoreException ex)&#123;            System.out.println(ex.getMessage());        &#125;    &#125;&#125;class ScoreException extends Exception &#123;    //write your code here......    public ScoreException(String message) &#123;        super(message);    &#125;&#125;</code></pre><h2 id="38-字符串去重"><a href="#38-字符串去重" class="headerlink" title="38. 字符串去重"></a>38. 字符串去重</h2><pre><code class="java">import java.util.HashSet;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.nextLine();        scanner.close();        HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;();        //write your code here......        for (int i = 0; i &lt; str.length(); i++) &#123;            hs.add(str.charAt(i));        &#125;        for (char c:hs) &#123;            System.out.print(c);        &#125;    &#125;&#125;</code></pre><h2 id="39-集合遍历"><a href="#39-集合遍历" class="headerlink" title="39. 集合遍历"></a>39. 集合遍历</h2><pre><code class="java">import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int num1 = scanner.nextInt();        int num2 = scanner.nextInt();        int num3 = scanner.nextInt();        int num4 = scanner.nextInt();        int num5 = scanner.nextInt();        scanner.close();        list.add(num1);        list.add(num2);        list.add(num3);        list.add(num4);        list.add(num5);        System.out.print(&quot;普通for循环:&quot;);        //write your code here......        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.print(list.get(i) + &quot; &quot;);        &#125;        System.out.println();        System.out.print(&quot;增强for循环:&quot;);        //write your code here......        for (int n: list) &#123;            System.out.print(n + &quot; &quot;);        &#125;        System.out.println();        System.out.print(&quot;迭代器遍历:&quot;);        //write your code here......        Iterator iter =  list.listIterator();        while (iter.hasNext()) &#123;            System.out.print(iter.next() + &quot; &quot;);        &#125;        System.out.println();    &#125;&#125;</code></pre><h2 id="40-排队系统"><a href="#40-排队系统" class="headerlink" title="40. 排队系统"></a>40. 排队系统</h2><pre><code class="java">//write your code here......deque.addFirst(vipGuest);</code></pre><h2 id="41-Head-and-Tail-of-the-Queue"><a href="#41-Head-and-Tail-of-the-Queue" class="headerlink" title="41. Head and Tail of the Queue"></a>41. Head and Tail of the Queue</h2><pre><code class="java">// write your code here......boolean turnToHead = true;while (!deque.isEmpty()) &#123;    if (turnToHead) &#123;        System.out.println(deque.removeFirst());    &#125; else &#123;        System.out.println(deque.removeLast());    &#125;    turnToHead = !turnToHead;&#125;</code></pre><h2 id="42-统计一句话中重复单词的个数"><a href="#42-统计一句话中重复单词的个数" class="headerlink" title="42. 统计一句话中重复单词的个数"></a>42. 统计一句话中重复单词的个数</h2><pre><code class="java">//write your code here......for (int i = 0; i &lt; line.length(); i++) &#123;    Character c = line.charAt(i);    if (Character.isAlphabetic(c)) &#123;        Integer originNum = map.get(c);        if (originNum == null) &#123;            map.put(c, 1);        &#125; else &#123;            map.put(c, originNum + 1);        &#125;    &#125;&#125;</code></pre><h2 id="43-map简单应用"><a href="#43-map简单应用" class="headerlink" title="43. map简单应用"></a>43. map简单应用</h2><pre><code class="java">//write your code here......Set&lt;Integer&gt; keySet = map.keySet();Iterator&lt;Integer&gt; iter = keySet.iterator();while (iter.hasNext()) &#123;    Integer key = iter.next();    System.out.println(key + &quot;:&quot; + map.get(key));&#125;System.out.println();map.put(5, name);map.remove(4);map.put(3, &quot;Tommy&quot;);iter = keySet.iterator();while (iter.hasNext()) &#123;    Integer key = iter.next();    System.out.println(key + &quot;:&quot; + map.get(key));&#125;</code></pre><h2 id="44-集合排序"><a href="#44-集合排序" class="headerlink" title="44. 集合排序"></a>44. 集合排序</h2><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        //其余代码省略        //write your code here......        Collections.sort(customers);        System.out.println(customers);    &#125;&#125;class Customer implements Comparable&lt;Customer&gt;&#123;    //其余代码省略    //write your code here......    @Override    public int compareTo(Customer other) &#123;        return other.consumption - consumption;    &#125;&#125;</code></pre><h2 id="45-判断各类型字符个数"><a href="#45-判断各类型字符个数" class="headerlink" title="45. 判断各类型字符个数"></a>45. 判断各类型字符个数</h2><pre><code class="java">//write your code here......for (int i = 0; i &lt; str.length(); i++) &#123;    if (str.charAt(i) == &#39; &#39;) &#123;        space++;    &#125; else if (Character.isAlphabetic(str.charAt(i))) &#123;        words++;    &#125; else if (Character.isDigit(str.charAt(i))) &#123;        numbers++;    &#125; else &#123;        other++;    &#125;&#125;</code></pre><h2 id="46-编写个人所得税计算程序"><a href="#46-编写个人所得税计算程序" class="headerlink" title="46. 编写个人所得税计算程序"></a>46. 编写个人所得税计算程序</h2><pre><code class="java">import java.util.*;public class Main &#123;    //税率    private static final double[] taxRates = &#123;0.03, 0.1, 0.2, 0.25, 0.3, 0.35, 0.45&#125;;    //速算扣除数    private static final double[] shouldMinus = &#123;0.0, 105.0, 555.0, 1005.0, 2755.0, 5505.0, 13505.0&#125;;    public static void main(String[] args) &#123;        List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();        //write your code here......        //应纳税额 =（工资薪金所得－扣除数）×适用税率－速算扣除数        //扣除数为3500元        //全月应纳税所得额=工资薪金所得－扣除数。        employees.add(new Employee(&quot;小明&quot;, 2500));        employees.add(new Employee(&quot;小军&quot;, 8000));        employees.add(new Employee(&quot;小红&quot;, 100000));        for (Employee emp : employees) &#123;            System.out.println(emp.getName() + &quot;应该缴纳的个人所得税是：&quot; + getTax(emp));        &#125;    &#125;    /**     * 自定义方法，输入一个雇员，返回雇员所得税。     */    public static double getTax(Employee emp) &#123;        double salary = emp.getSalary();        if (Double.compare(salary, 3500) &lt; 0) &#123;            return 0.0;        &#125;                double monthIncome = salary - 3500.0;//全月应纳税所得额        if (Double.compare(monthIncome, 1500.0) &lt;= 0) &#123;            return monthIncome * taxRates[0] - shouldMinus[0];        &#125; else if (Double.compare(monthIncome, 4500.0) &lt;= 0) &#123;            return monthIncome * taxRates[1] - shouldMinus[1];        &#125; else if (Double.compare(monthIncome, 9000.0) &lt;= 0) &#123;            return monthIncome * taxRates[2] - shouldMinus[2];        &#125; else if (Double.compare(monthIncome, 35000.0) &lt;= 0) &#123;            return monthIncome * taxRates[3] - shouldMinus[3];        &#125; else if (Double.compare(monthIncome, 55000.0) &lt;= 0) &#123;            return monthIncome * taxRates[4] - shouldMinus[4];        &#125; else if (Double.compare(monthIncome, 80000.0) &lt;= 0) &#123;            return monthIncome * taxRates[5] - shouldMinus[5];        &#125; else&#123;            return monthIncome * taxRates[6] - shouldMinus[6];        &#125;    &#125;&#125;class Employee&#123;    private String name;    private double salary;    public Employee(String name, double salary) &#123;        this.name = name;        this.salary = salary;    &#125;    public String getName() &#123;        return name;    &#125;    public double getSalary() &#123;        return salary;    &#125;&#125;</code></pre><h2 id="47-记录点赞用户"><a href="#47-记录点赞用户" class="headerlink" title="47. 记录点赞用户"></a>47. 记录点赞用户</h2><pre><code class="java">class LikeRecorderImpl implements LikeRecorder &#123;    // write your code here......    private static final HashSet&lt;String&gt; likeNames = new HashSet&lt;&gt;();    @Override    public void like(String username) &#123;        if (likeNames.contains(username)) &#123;            likeNames.remove(username);            return;        &#125;        likeNames.add(username);    &#125;    @Override    public String[] getLikeUsers() &#123;        String[] result = new String[likeNames.size()];        return likeNames.toArray(result);    &#125;&#125;</code></pre><h2 id="48-回文数判断"><a href="#48-回文数判断" class="headerlink" title="48. 回文数判断"></a>48. 回文数判断</h2><pre><code class="java">public Boolean palindromeNumber(int number) &#123;    //write your code here......    String numberStr = &quot;&quot; + number;    for (int i = 0; i &lt; numberStr.length() / 2; i++) &#123;        if (numberStr.charAt(i) != numberStr.charAt(numberStr.length() - i - 1)) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><h2 id="49-判断素数个数"><a href="#49-判断素数个数" class="headerlink" title="49. 判断素数个数"></a>49. 判断素数个数</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int start = scanner.nextInt();        int end = scanner.nextInt();        method(start,end);    &#125;    public static void method(int start, int end) &#123;        int count=0;        //write your code here......        start = start &gt; end ? end + 0 * (end = start) : start;//如果start &gt; end交换start和end的值        for (int i = start; i &lt;= end; i++) &#123;            if (isPrimeGreaterThan2(i)) &#123;                count++;            &#125;        &#125;        System.out.println(start+&quot;到&quot;+end+&quot;之间有&quot;+count+&quot;个大于2的素数&quot;);    &#125;    public static boolean isPrimeGreaterThan2(int n) &#123;        if (n &lt;= 2)            return false;        for (int i = 2; i &lt;= n / 2; i++) &#123;            if (n % i == 0)                return false;        &#125;        return true;    &#125;&#125;</code></pre><h2 id="50-根据周长求面积"><a href="#50-根据周长求面积" class="headerlink" title="50. 根据周长求面积"></a>50. 根据周长求面积</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextDouble()) &#123;            double s = scanner.nextDouble();            // Circle和Square是需要你定义的类            System.out.println(String.format(&quot;%.3f&quot;,new Circle(s).getArea()));            System.out.println(String.format(&quot;%.3f&quot;, new Square(s).getArea()));        &#125;    &#125;&#125;class Shape &#123;    private double s; // 周长    public Shape(double s) &#123;        this.s = s;    &#125;    public double getS() &#123;        return s;    &#125;&#125;interface Area &#123;    double getArea(); // 面积&#125;// 圆形class Circle extends Shape implements Area &#123;    //write your code here......    public Circle(double s) &#123;        super(s);    &#125;    @Override    public double getArea() &#123;        double radius = getS() / (2 * Math.PI);        return radius * radius * Math.PI;    &#125;&#125;// 方形class Square extends Shape implements Area &#123;    //write your code here......    public Square(double s) &#123;        super(s);    &#125;    @Override    public double getArea() &#123;        double radius = getS() / 4;        return radius * radius;    &#125;&#125;</code></pre><h2 id="51-冒泡排序"><a href="#51-冒泡排序" class="headerlink" title="51. 冒泡排序"></a>51. 冒泡排序</h2><pre><code class="java">//write your code here......int temp;for (int i = arr.length - 1; i &gt;= 0; i--) &#123;    for (int j  = 0; j &lt; i; j++) &#123;        if (arr[j] &gt; arr[j+1]) &#123;            temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;牛客Java语法篇&quot;&gt;&lt;a href=&quot;#牛客Java语法篇&quot; class=&quot;headerlink&quot; title=&quot;牛客Java语法篇&quot;&gt;&lt;/a&gt;牛客Java语法篇&lt;/h1&gt;&lt;p&gt;这些题大体都没什么难度，做这些题的目的是为了熟悉Java类库。&lt;br&gt;绝大部分题都是</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
