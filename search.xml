<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS 61B学习记录</title>
      <link href="/2023/08/25/CS61B/"/>
      <url>/2023/08/25/CS61B/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是UCB开给计算机系本科生的一门数据结构与算法课，看了一下<a href="https://github.com/PKUFlyingPig">@PKUFlyingPig</a>的介绍觉得挺有趣的，同时也想让自己的算法更扎实一点，遂决定刷一下这门课。我选择学习该课程的18年春季的存档，虽然是18年开设的，但是官方给出的<a href="gradescope.com">gradescope</a>邀请码还能使用，在这里感谢这些愿意开源计算机课程的老师。</p><h2 id="Labs"><a href="#Labs" class="headerlink" title="Labs"></a>Labs</h2><h3 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h3><h4 id="A-Java-Compilation-amp-Development"><a href="#A-Java-Compilation-amp-Development" class="headerlink" title="A. Java Compilation &amp; Development"></a>A. Java Compilation &amp; Development</h4><p>两个简单的demo，经典的Hello World和打印0~9的累加。</p><p>打印0~9的累加（省略不重要的部分）：</p><pre><code class="java">int x = 0;        int total = 0;        while (x &lt; 10) &#123;            System.out.print(total + &quot; &quot;);            x = x + 1;            total += x;        &#125;</code></pre><h4 id="B-Git-amp-Local-Repos"><a href="#B-Git-amp-Local-Repos" class="headerlink" title="B. Git &amp; Local Repos"></a>B. Git &amp; Local Repos</h4><p>阅读Sarah Kim写的<a href="https://sp18.datastructur.es/materials/guides/using-git.html">Using Git Guide</a>的A-C部分。</p><h4 id="C-Git-Exercise"><a href="#C-Git-Exercise" class="headerlink" title="C. Git Exercise"></a>C. Git Exercise</h4><p>练习了一下init、add、commit操作。</p><h4 id="D-E"><a href="#D-E" class="headerlink" title="D, E"></a>D, E</h4><p>都是一些设置git仓库的操作，这里省略。</p><h4 id="F-Leap-Year"><a href="#F-Leap-Year" class="headerlink" title="F. Leap Year"></a>F. Leap Year</h4><p>Leap Year，即闰年，又是一个经典的入门级算法。</p><pre><code class="java">/**      * Test a year is whether or not a leap year.     * @param year year to be tested*/    public static boolean isLeapYear(int year) &#123;      return year%400 == 0 || (year%4 == 0 &amp;&amp; year%100 != 0);     &#125;</code></pre><h3 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab 2"></a>Lab 2</h3><p>这个实验主要过程是进行调试练习并且为IntList.java创建方法。</p><p>条件断点：</p><ul><li>右键点击一个断点符号（在我的版本里是一个红色的圆圈），然后可以在condition栏里输入想要的条件断点表达式。</li></ul><p>Destructive vs. Non-Destructive:</p><ul><li>Destructive(或者mutative)方法指会修改原来的对象的方法（参数或者类成员），而Non-Destructive方法相反。</li></ul><p>实现InitList的dcatenate和catenate方法，这里我都用递归的方法实现:</p><ul><li><p>dcatenate:</p><pre><code class="java">/**     * Returns a list consisting of the elements of A followed by the     * *  elements of B.  May modify items of A. Don&#39;t use &#39;new&#39;.     */public static IntList dcatenate(IntList A, IntList B) &#123;        //TODO:  fill in method        if (A == null &amp;&amp; B == null) &#123;            return null;        &#125;        if (A == null) &#123;            return new IntList(B.first, B.rest);        &#125;        if (B == null) &#123;            return A;        &#125;        A.rest = dcatenate(A.rest, B);        return A;    &#125;</code></pre></li><li><p>catenate:</p><pre><code class="java">/**     * Returns a list consisting of the elements of A followed by the     * * elements of B.  May NOT modify items of A.  Use &#39;new&#39;.     */    public static IntList catenate(IntList A, IntList B) &#123;        //TODO:  fill in method        if (A == null &amp;&amp; B == null) &#123;            return null;        &#125;        if (A == null) &#123;            return new IntList(B.first, catenate(null, B.rest));        &#125;        return new IntList(A.first, catenate(A.rest, B));    &#125;</code></pre></li></ul><h3 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab 3"></a>Lab 3</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li><p>什么是JUnit？</p><p>JUnit是Java专用的单元测试框架。</p></li><li><p>什么是单元测试？</p><p>如果你可以将你的程序分为许多个单元(Unit)，那么你可以对这些单元分别进行测试，这就叫做单元测试。单元测试可以在完成整个程序前对每个单元进行边缘测试等，保证程序的健壮性。</p></li><li><p>JUnit语法</p><ul><li>在每一个测试方法前加上@Test注解。</li><li><code>assertEquals</code>是JUnit中一个常用的方法，它测试一个值是否与它所被期望的值相等。类似的还有<code>assertTrue</code>等。</li></ul></li></ul><h4 id="IntelliJ中运行JUnit测试"><a href="#IntelliJ中运行JUnit测试" class="headerlink" title="IntelliJ中运行JUnit测试"></a>IntelliJ中运行JUnit测试</h4><ul><li><p>执行单个测试，直接右键点击带有@Test注解的方法的签名的左边的绿色小三角，然后运行测试即可。</p><p><img src="C:\Users\chen2\AppData\Roaming\Typora\typora-user-images\image-20230826161028627.png" alt="image-20230826161028627"></p></li><li><p>执行一个测试类中的所有单元测试，可以像运行带main方法的类一样。</p><p><img src="C:\Users\chen2\AppData\Roaming\Typora\typora-user-images\image-20230826161155756.png" alt="image-20230826161155756"></p></li></ul><h3 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h3><p>lab4是为了让UCB在读同学与其他同学进行交流，这里我跳过它了。除此之外还有教如何在IntelliJ中永久地设置库和SDK，设置后不用每一次打开项目都要添加一次库文件夹了。</p><p><img src="C:\Users\chen2\AppData\Roaming\Typora\typora-user-images\image-20230827124825038.png" alt="image-20230827124825038"></p><p>在这里添加库文件夹的路径即可。</p><h2 id="Projects"><a href="#Projects" class="headerlink" title="Projects"></a>Projects</h2><h3 id="Project-0"><a href="#Project-0" class="headerlink" title="Project 0"></a>Project 0</h3><p>这个项目完成之后可以模拟多种天体运动的情况，虽然是很简单的模拟，但是也非常有意思。由于项目中涉及到的数据结构相关的知识很少，所以这里不过多赘述。</p><h3 id="Project-1A"><a href="#Project-1A" class="headerlink" title="Project 1A"></a>Project 1A</h3><p>此项目将使用list和array实现一个双端队列。</p><p>双端队列API：</p><ul><li><code>public void addFirst(T item)</code></li><li><code>public void addLast(T item)</code></li><li><code>public boolean isEmpty()</code></li><li><code>public int size()</code></li><li><code>public void printDeque()</code></li><li><code>public T removeFirst()</code></li><li><code>public T removeLast()</code></li><li><code>public T get(int index)</code></li></ul><p>链表双端队列：</p><ul><li><p>为了<code>add</code>和<code>remove</code>操作能在常数时间内完成，可以记录链表的头结点和尾结点为head和tail。</p></li><li><p>用<code>size</code>来记录队列当前元素个数，每次更改队列大小时需要修改<code>size</code>。</p></li><li><p>除了以上提到的方法，还需要实现<code>public LinkedListDeque()</code>和<code>public T getRecursive(int index)</code></p></li><li><p>链式结构都需要定义节点类型，这里我们使用双链表来实现双端队列，结点类型以<code>LinkedListDeque</code>内部类的形式定义：</p><pre><code class="java">public class LinkedListDeque&lt;T&gt; &#123;    private class Node &#123;        public T data = null;        public Node next = null;        public Node prev = null;        public Node() &#123;&#125;        public Node(T data) &#123;            this.data = data;        &#125;        public Node(T data, Node next, Node prev) &#123;            this.data = data;            this.next = next;            this.prev = prev;        &#125;    &#125;    //省略其它内容&#125;</code></pre></li><li><p>实现<code>addFirst</code>:</p><ul><li>参数可以为null。</li><li>size要自增。</li><li>如果size为0，构造新节点，head和tail都指向新节点。</li><li>否则构造新节点，新节点的next指向head，head的prev指向新节点，并且head指向新节点。</li></ul></li><li><p>实现<code>removeFirst</code>:</p><ul><li>如果没有元素，返回null。</li><li>否则size–。</li><li>如果size为1，记录head的data为res，head和tail都变成null，返回res。</li><li>记录head的data为res，head&#x3D;head.next，head的prev置空。</li></ul></li><li><p>实现<code>get</code>:</p><ul><li>如果size为0，返回null。</li><li>如果index&lt;0或者index&gt;&#x3D;size，抛出异常，指出索引不正确。</li><li>从head开始查找。</li></ul></li><li><p>实现<code>getRecursive</code>:</p><ul><li>边缘情况与<code>get</code>类似。</li><li>当index为0时可以直接返回链表首元素的data。</li><li>一个长度为s的链表l，要获取l的第i个元素，可以获取除l首元素后剩下的链表的第i-1个元素。</li></ul></li></ul><p>数组双端队列：</p><ul><li><p>数组长度用length记录，队列长度用size记录。</p></li><li><p><code>add</code>和<code>move</code>要在常数时间内完成，可以用front和end分别记录队列的头和尾。</p></li><li><p>由于我们将数组当做环形来对待，所以需要仔细考虑队空和队满的状态。假设当front&#x3D;&#x3D;end时队列里有一个元素，那么当front在end后一个位置 (即(end+1)%length &#x3D;&#x3D; front时) 时队列可能为空，也可能为满，我们可以用size是否为0来判断。</p></li><li><p><code>get</code>和<code>size</code>必须在常数时间内完成。get时记得要对index+front取余。</p></li><li><p>数组初始化大小为8。</p></li><li><p>扩容&#x2F;减容操作：</p><ul><li>扩容发生在数组被填满，即size&#x3D;&#x3D;length，且有新元素进入队列时。数组容量扩大为原来的两倍。<ul><li>如果是进入队头，让新元素填入新数组索引为0的位置，然后原数组front<del>end的元素依次填入新数组1</del>size的位置。</li><li>如果是进入队尾，让原数组front<del>end的元素依次填入新数组0</del>size-1对应位置，然后让新元素填入新数组size的位置。</li></ul></li><li>减容发生在length &gt; 8，并且size &#x3D;&#x3D; length&#x2F;4 + 1，并且有元素要出队时。数组容量减小为原来的1&#x2F;2，并且数组元素个数为新length的一半。<ul><li>为什么不在size &#x3D;&#x3D; length&#x2F;2 + 1且有元素出队时减容呢？假设现在length为16，且有9个元素和有元素要出队，如果在size &#x3D;&#x3D; length&#x2F;2 + 1时就减容，那么新的length为8，新的size也为8，那如果此时又有新的元素要进入队列呢？我们又需要对队列进行扩容，扩容后如果有元素要出队列，我们又要减容……这样频繁的扩&#x2F;减容显然不是我们想看到的，所以我选择在size &#x3D;&#x3D; length&#x2F;4 + 1且有元素要出队时才减容。</li><li>先在原数组上修改front(队首元素出队)&#x2F;end(队尾元素出队)，然后将原数组front<del>end对应的元素复制到新数组0</del>size-2的位置上。</li></ul></li></ul></li><li><p>私有成员:</p><pre><code class="java">private int length; //数组长度private int size; //元素个数private int front; //队列头索引private int end; //队列尾索引private T[] data; //存放元素的数组</code></pre></li><li><p>实现<code>expand</code>和<code>contract</code>:</p><ul><li>这两个方法对应扩容和减容，其核心逻辑在上面已经描述过了。</li></ul></li><li><p>实现<code>addFirst</code>:</p><ul><li>如果队列已满则扩容，否则：front往前移一个位置，front处添加新元素。</li><li>size++。</li></ul></li><li><p>实现<code>addLast</code>:</p><p>逻辑与addFirst相似，除了在添加时应该让end往后移动。</p></li><li><p>实现<code>removeFirst</code>:</p><ul><li>先获得返回结果res为data[front]。如果队列满足length&gt;8，且size &#x3D;&#x3D; length&#x2F;4 + 1则减容，否则：front处的元素置空，front往后移动一个位置。</li><li>size–。</li></ul></li><li><p>实现<code>removeLast</code>:</p><ul><li>逻辑与removeFirst相似，除了在移除时应该让end往前移动。</li></ul></li></ul><h3 id="Project-1B"><a href="#Project-1B" class="headerlink" title="Project 1B"></a>Project 1B</h3><h4 id="任务一：Deque接口"><a href="#任务一：Deque接口" class="headerlink" title="任务一：Deque接口"></a>任务一：Deque接口</h4><ul><li><p>定义Deque接口：</p><pre><code class="java">public interface Deque&lt;T&gt; &#123;    public void addFirst(T item);    public void addLast(T item);    public boolean isEmpty();    public int size();    public void printDeque();    public T removeFirst();    public T removeLast();    public T get(int index);&#125;</code></pre></li><li><p>在Project 1A中我们定义了ArrayDeque类，现在让ArrayDeque成为Deque的实现类：</p><pre><code class="java">public class ArrayDeque&lt;T&gt; implements Deque&lt;T&gt;&#123;    //省略&#125;</code></pre></li></ul><h4 id="任务二：Task-2-wordToDeque"><a href="#任务二：Task-2-wordToDeque" class="headerlink" title="任务二：Task 2: wordToDeque"></a>任务二：Task 2: wordToDeque</h4><ul><li><p>wordToDeque签名</p><p><code>public Deque&lt;Character&gt; wordToDeque(String word)</code></p></li><li><p>实现思路：</p><p>定义Deque&lt;Character&gt; res用来返回最终结果。从word取出每一个字符c，每次取出字符就调用res.addLast(c)。最后返回res。</p></li></ul><h4 id="任务三：isPalindrome"><a href="#任务三：isPalindrome" class="headerlink" title="任务三：isPalindrome"></a>任务三：isPalindrome</h4><ul><li><p>isPalindrome签名</p><p><code>public boolean isPalindrome(String word)</code></p></li><li><p>官方给出的一些建议：</p><ul><li>使用wordToDeque来实现</li><li>使用递归实现</li></ul></li><li><p>实现思路：</p><ul><li><p>首先我们规定null传入isPalindrome时返回false，规定空串是回文字符串。</p></li><li><p>思路：为了方便操作，我们使用wordToDeque方法先将word转成一个字符队列que，然后将que传入isPalindromeHelper，并且将isPalindromeHelper(que)的返回值返回。定义方法<code>private boolean isPalindromeHelper(Deque&lt;Character&gt; que)</code>，该方法接收一个字符队列，并且判断队列中的字符是否构成回文字符串。</p></li><li><p>由isPalindromeHelper进行递归：</p><ul><li><p>如果que为空或者que中只有一个字符，返回true。</p></li><li><p>否则判断que第一个元素和最后一个元素是否相同(比较前先将首尾元素出队)，如果相同，返回isPalindromeHelper(que)，注意这时que已经去掉首尾元素了；如果不同，直接返回false。</p></li></ul></li></ul></li></ul><h4 id="任务四：通用Palindrome和OffByOne"><a href="#任务四：通用Palindrome和OffByOne" class="headerlink" title="任务四：通用Palindrome和OffByOne"></a>任务四：通用Palindrome和OffByOne</h4><ul><li><p>重载isPalindrome签名</p><p><code>public boolean isPalindrome(String word, CharacterComparator cc)</code></p></li><li><p>实现思路：</p><p>思路与上面的isPalindrome几乎一样，只是在helper函数中取出首尾字符后，使用参数cc的charEquals函数判断两个字符是否相等。</p></li></ul><h4 id="任务五：OffByN"><a href="#任务五：OffByN" class="headerlink" title="任务五：OffByN"></a>任务五：OffByN</h4><p>非常简单，就是在传入的两个char之差为n时返回true，否则返回false。</p><h2 id="HWs"><a href="#HWs" class="headerlink" title="HWs"></a>HWs</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构与算法 </tag>
            
            <tag> 国外计算机课程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次关于TreeMap的使用的坑</title>
      <link href="/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/"/>
      <url>/2023/06/09/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%85%B3%E4%BA%8ETreeMap%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>今天在做《牛客算法必刷101》的最后一题时遇到了一个坑。原题目这里就不赘述了，原题目地址：</p><p><a href="https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&tqId=1006014&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=/exam/oj">https://www.nowcoder.com/practice/93aacb4a887b46d897b00823f30bfea1?tpId=295&amp;tqId=1006014&amp;ru=/exam/oj&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Foj</a></p><p>定义<code>TreeMap&lt;int[], Integer&gt; orderedMap </code>,要求orderedMap（下文简称map）的键长度为3，并且给出map的完整定义：</p><pre><code class="java">private TreeMap&lt;int[], Integer&gt; orderedMap = new TreeMap&lt;&gt;(new Comparator&lt;int[]&gt;() &#123;    @Override    public int compare(int[] a, int[] b) &#123;        //如果调用次数不等，次数少的排在前面        if (a[1] != b[1])            return a[1] - b[1];        //如果调用次数相等，调用时间早的排在前面        return a[2] - b[2];    &#125;&#125;);</code></pre><p>这里我想表达的是：对于map中的两个键，如果一个键的第二个元素小于另一个键的第二个元素，那么这个键排在另一个键的前面；如果这两个键相等，那么键的第三个元素小的排前面。</p><p>现在假设map中现有几个元素</p><pre><code class="java">[1, 1, 0] -&gt;  1[4, 2, 4] -&gt;  4[3, 2, 5] -&gt;  3[2, 2, 6] -&gt;  2</code></pre><p>可以看到现在map中元素的顺序是正确的，如果我用一个变量data记录了map中的第一个键，就像这样（实际我的代码中是通过其它方式获得这个键的，这里为了简洁就直接从map中获得了）：</p><pre><code class="java">int[] data = orderedMap.firstKey();</code></pre><p>现在如果我通过data修改数组为[1,2,7]：</p><pre><code class="java">data[1] = 2;data[2] = 7;</code></pre><p>然后我将data从map中删除，然后再将data添加到map中不就可以保持map中的元素有序了吗？</p><pre><code class="java">orderedMap.remove(data);orderedMap.put(data, key);//这里key是map中data还没被删除时对应的值</code></pre><p>然而是我太天真了，这样做<code>orderedMap.remove(data)</code> 返回的居然是null。这就奇了怪了，我的data明明是存在map中的啊，怎么删除data会返回null呢？也就是说怎么会找不到**[1,2,7]**呢？print调试找不出错误了，只好将代码粘贴到idea中进行调试。下面是方法调用过程：</p><pre><code class="java">public V remove(Object key) &#123;    Entry&lt;K,V&gt; p = getEntry(key);    if (p == null)        return null;    V oldValue = p.value;    deleteEntry(p);    return oldValue;&#125;</code></pre><p>remove方法会先调用getEntry方法：</p><pre><code class="java">final Entry&lt;K,V&gt; getEntry(Object key) &#123;    // Offload comparator-based version for sake of performance        if (comparator != null)        return getEntryUsingComparator(key);        /*    下面的代码不用看    if (key == null)        throw new NullPointerException();    @SuppressWarnings(&quot;unchecked&quot;)    Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;    Entry&lt;K,V&gt; p = root;    while (p != null) &#123;        int cmp = k.compareTo(p.key);        if (cmp &lt; 0)            p = p.left;        else if (cmp &gt; 0)            p = p.right;        else            return p;    &#125;    return null;*/&#125;</code></pre><p>这里comparator是在定义map时传入的，不为空，所以会进入getEntryUsingComparator这个方法：</p><pre><code class="java">final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123;    @SuppressWarnings(&quot;unchecked&quot;)    K k = (K) key;    Comparator&lt;? super K&gt; cpr = comparator;    if (cpr != null) &#123;        Entry&lt;K,V&gt; p = root;        while (p != null) &#123;            int cmp = cpr.compare(k, p.key);            if (cmp &lt; 0)                p = p.left;            else if (cmp &gt; 0)                p = p.right;            else                return p;        &#125;    &#125;    return null;&#125;</code></pre><p>重点在if语句，由于TreeMap是基于红黑树的数据结构，<strong>查找的时候不会遍历每一个元素</strong>，而是<strong>从根节点开始查找</strong>，如果<code>compare(k, p.key)</code> 返回0，就可以将p返回；如果返回值小于0，则在树的左半边查找；如果返回值大于0，则在树的右半边查找。</p><p>看到这里我们大致知道为什么<code>orderedMap.remove(data)</code> 返回null了：一开始data在红黑树的某个位置x，修改data中的数据后，我们查找data就是在树中<strong>查找新的data应该在的位置</strong>，但是我们通过data修改map中的一个键，并不会让树重新有序（remove后再put就是想让树保持有序），也就是说data所在的位置是错误的。在map中找不到data当然通过data删除也就不行了。</p><p>如何完成正确重新排序呢？答案是先将data从map中移除（因为这个时候还没修改data中的数据，是可以从map中正确删除data的），通过data修改数据后再将data添加到map中。</p><pre><code class="java">orderedMap.remove(data);data[1] = 2;data[2] = 7;orderedMap.put(data, key);//这里key是map中data还没被删除时对应的值</code></pre><p>这样map中的数据将会是有序的（还记得排序规则吗：键的第二个元素相同时，第三个元素小的排前面，所以[1,2,7]在最后）：</p><pre><code class="java">[4, 2, 4] -&gt;  4[3, 2, 5] -&gt;  3[2, 2, 6] -&gt;  2[1, 2, 7] -&gt;  1</code></pre><p>总结：如果修改TreeMap中的键并且想保持有序，需要先移除键，在修改操作完成后再将键存入TreeMap！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Java中，0.4被传入System.out.print时发生了什么？</title>
      <link href="/2023/06/09/%E5%9C%A8Java%E4%B8%AD%EF%BC%8C0.4%E8%A2%AB%E4%BC%A0%E5%85%A5System.out.print%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2023/06/09/%E5%9C%A8Java%E4%B8%AD%EF%BC%8C0.4%E8%A2%AB%E4%BC%A0%E5%85%A5System.out.print%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>在看JavaGuide复习Java基础知识的时候，看到了浮点数表示的章节。突然想知道，为什么0.4明明不能被准确表示，但是在传入System.out.println时显示到控制台的却是0.4呢？</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4    &#125;&#125;</code></pre><p>在继续阅读之前，我希望你能够具备一定的前置知识：</p><ul><li>了解浮点数是如何在计算机中表示的</li><li>了解不是所有实数都能被准确表示</li><li>0.4就是不能被准确表示的数之一</li><li>了解BigDecimal类</li></ul><p>我们可以通过BigDecimal类和System.out.println（以下简称print）来打印一个double的实际值：</p><pre><code class="java">import java.math.BigDecimal;public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4        System.out.println(new BigDecimal(d1));//打印结果：0.40000000000000002220446049250313080847263336181640625    &#125;&#125;</code></pre><p>通过上面的代码和其运行结果可以看出，当0.4被当做double字面量时，其真实值其实是0.40000000000000002220446049250313080847263336181640625。那print打印d1的时候不应该显示0.40000000000000002220446049250313080847263336181640625吗？</p><p>那为什么将d1传入print却得到0.4呢？首先我们进行一个猜想：是不是在定义变量d1时，其对应的字面量（即在写代码的时候直接写在代码中的0.4）被虚拟机记录成这样的形式(d1 –&gt; “0.4”)，然后在将double传入print时，print在虚拟机中找到d1对应的”0.4”然后打印”0.4”？这样好像是可行的，但是会有一些问题，例如：不是所有的double变量都是通过字面量直接定义的，如果这样定义d1<code> double d1 = 0.2 * 2</code> 虚拟机就不能获取”d1 –&gt;0.4”这样的信息了。难道虚拟机会记录(d1 –&gt; “0.2 * 2”)，然后在打印时打印0.2 * 2到屏幕上吗？显然不合理。那么print到底是怎么做的呢？</p><p>像0.40000000000000002220446049250313080847263336181640625这样一个值可以表示一个范围内的实数，例如从</p><pre><code class="java">import java.math.BigDecimal;public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        double d2 = 0.400000000000000000001;                System.out.println(d1);//0.4        System.out.println(d2);//0.4                System.out.println(new BigDecimal(d1));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d2));//0.40000000000000002220446049250313080847263336181640625    &#125;&#125;</code></pre><p>这个代码段可以看出0.4和0.400000000000000000001其实用的是同一个真实值来表示，即0.40000000000000002220446049250313080847263336181640625的表示范围中包含了0.4和0.400000000000000000001。<br>而double传入print时，虚拟机会调用Double.toString(double d)这个方法来将double转成一个String。而Double.toString(double d)这个方法会将参数d转换成它范围内的有效位最少的数字。例如，假设0.40000000000000002220446049250313080847263336181640625表示范围为[0.40000000000000002220446049250313080847263336181640625 - x, 0.40000000000000002220446049250313080847263336181640625 + y]，那么落在这个范围的数字通过toString转换都变成了”0.4”。而0.4000001和0.40000010000000001都落到0.400000100000000025080026944124256260693073272705078125这个数字的表示范围，通过toString转换都会变成0.4000001。</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        double d2 = 0.400000000000000000001;        double d3 = 0.4000001;        double d4 = 0.40000010000000001;                System.out.println(d1);//0.4        System.out.println(d2);//0.4        System.out.println(d3);//0.4000001        System.out.println(d4);//0.4000001                System.out.println(new BigDecimal(d1));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d2));//0.40000000000000002220446049250313080847263336181640625        System.out.println(new BigDecimal(d3));//0.400000100000000025080026944124256260693073272705078125        System.out.println(new BigDecimal(d4));//0.400000100000000025080026944124256260693073272705078125            &#125;&#125;</code></pre><p>总结一下：</p><pre><code class="java">public class Main&#123;    public static void main(String[] args) &#123;        double d1 = 0.4;        System.out.println(d1);//打印结果：0.4    &#125;&#125;</code></pre><p>这段程序可以看做经历了几个阶段：</p><ul><li>定义d1，d1的真实值为0.40000000000000002220446049250313080847263336181640625</li><li>d1被Double.toString(double)方法转换成”0.4”</li><li>“0.4”被打印到屏幕上</li></ul><p>参考:</p><ul><li><a href="https://stackoverflow.com/questions/588004/is-floating-point-math-broken">https://stackoverflow.com/questions/588004/is-floating-point-math-broken</a></li><li><a href="https://stackoverflow.com/questions/22526897/how-does-java-precisely-display-a-double-while-it-cannot-be-accurately-expressed">https://stackoverflow.com/questions/22526897/how-does-java-precisely-display-a-double-while-it-cannot-be-accurately-expressed</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html">https://docs.oracle.com/javase/8/docs/api/index.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客在线编程之Java语法</title>
      <link href="/2023/06/09/%E7%89%9B%E5%AE%A2%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/06/09/%E7%89%9B%E5%AE%A2%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E4%B9%8BJava%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="牛客Java语法篇"><a href="#牛客Java语法篇" class="headerlink" title="牛客Java语法篇"></a>牛客Java语法篇</h1><p>这些题大体都没什么难度，做这些题的目的是为了熟悉Java类库。<br>绝大部分题都是直接贴上答案，但是少部分题的某些知识有所遗忘，我也会将我的学习过程写到对应题目处。</p><h2 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h2><pre><code class="java">public static int typeConversion(double d)&#123;    //write your code here......    return (int) d;&#125;</code></pre><h2 id="2-简单运算"><a href="#2-简单运算" class="headerlink" title="2. 简单运算"></a>2. 简单运算</h2><pre><code class="java">int bigger = a &gt; b ? a : b;int smaller = a;if (bigger == a)    smaller = b;System.out.print(bigger + smaller);System.out.print(&quot; &quot;);System.out.print(bigger - smaller);System.out.print(&quot; &quot;);System.out.print(bigger * smaller);System.out.print(&quot; &quot;);System.out.print(bigger / smaller);System.out.print(&quot; &quot;);System.out.print(bigger % smaller);System.out.print(&quot; &quot;);</code></pre><h2 id="3-四舍五入"><a href="#3-四舍五入" class="headerlink" title="3. 四舍五入"></a>3. 四舍五入</h2><p>由于题目要求将double四舍五入为int，所以用Math.round方法。</p><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double d = scanner.nextDouble();        //write your code here......        int i = (int)Math.round(d);        System.out.println(i);    &#125;&#125;</code></pre><h2 id="4-交换变量值"><a href="#4-交换变量值" class="headerlink" title="4. 交换变量值"></a>4. 交换变量值</h2><p>为了方便注释，统一假设a、b原来的值为A,B</p><ul><li><p>方法1</p><pre><code class="java">a = a + b;// a = A + Bb = a - b;// b = A + B - B = Aa = a - b;// a = A + B - A = B</code></pre></li><li><p>方法2</p><pre><code class="java">a = a ^ b;// a = A ^ Bb = a ^ b;// b = A ^ B ^ B = Aa = a ^ b;// a = A ^ B ^ A = B</code></pre><p>理解这种做法首先要知道:</p><ul><li>A ^ A &#x3D; 0</li><li>0 ^ A &#x3D; A</li></ul></li></ul><p>上面这两种方法都是用其中一个变量保存两个变量的状态，就好像是让两个变量的值共存与一个变量(a + b、a ^ b）。然后通过某种运算从两种状态的变量提取出其中的某一个状态。</p><ul><li><p>方法3</p><pre><code class="java">i = j + (j = i) * 0;</code></pre></li></ul><p>这种方法利用了0*A &#x3D; 0,0 + A &#x3D; A，还有在Java中如果一个赋值号右边发生了赋值，右边的变量进行运算时还是使用原来的值。在其它语言中这种方法不一定适用。</p><h2 id="5-计算商场折扣"><a href="#5-计算商场折扣" class="headerlink" title="5. 计算商场折扣"></a>5. 计算商场折扣</h2><pre><code class="java">import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner console = new Scanner(System.in);        int price = console.nextInt();        int cost = price;        //write your code here......        if (price &gt;= 5000) &#123;            cost = (int) (price * 0.6);        &#125; else if (price &gt;= 2000) &#123;            cost = (int) (price * 0.7);        &#125; else if (price &gt;= 500) &#123;            cost = (int) (price * 0.8);        &#125; else if (price &gt;= 100) &#123;            cost = (int) (price * 0.9);        &#125;        System.out.println(cost);    &#125;&#125;</code></pre><h2 id="6-判断体重指数"><a href="#6-判断体重指数" class="headerlink" title="6. 判断体重指数"></a>6. 判断体重指数</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        double height = scanner.nextDouble();        double weight = scanner.nextDouble();        //write your code here......        double index = weight / (height * height);        if (index &lt; 18.5) &#123;            System.out.print(&quot;偏瘦&quot;);        &#125; else if (index &lt; 20.9) &#123;            System.out.print(&quot;苗条&quot;);        &#125; else if (index &lt; 24.9) &#123;            System.out.print(&quot;适中&quot;);        &#125; else &#123;            System.out.print(&quot;偏胖&quot;);        &#125;    &#125;&#125;</code></pre><h2 id="7-判断学生成绩等级"><a href="#7-判断学生成绩等级" class="headerlink" title="7. 判断学生成绩等级"></a>7. 判断学生成绩等级</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String grade =scanner.next();        //write your code here......        if (grade == null) &#123;            System.out.print(&quot;未知等级&quot;);            return;        &#125;        if (grade.equals(&quot;A&quot;)) &#123;            System.out.print(&quot;优秀&quot;);        &#125; else if (grade.equals(&quot;B&quot;)) &#123;            System.out.print(&quot;良好&quot;);        &#125; else if (grade.equals(&quot;C&quot;)) &#123;            System.out.print(&quot;及格&quot;);        &#125; else if (grade.equals(&quot;D&quot;)) &#123;            System.out.print(&quot;不及格&quot;);        &#125; else &#123;            System.out.print(&quot;未知等级&quot;);        &#125;    &#125;&#125;</code></pre><h2 id="8-邮箱验证"><a href="#8-邮箱验证" class="headerlink" title="8. 邮箱验证"></a>8. 邮箱验证</h2><pre><code class="java">import java.util.Scanner;import java.util.regex.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.next();        String emailMatcher=&quot;[a-zA-Z0-9]+@[a-zA-Z0-9]+\\.[a-zA-Z0-9]+&quot;;        //write your code here......        boolean isEmail = Pattern.matches(emailMatcher, str);        if (isEmail) &#123;            System.out.print(&quot;邮箱格式合法&quot;);        &#125; else &#123;            System.out.print(&quot;邮箱格式不合法&quot;);        &#125;    &#125;&#125;</code></pre><p>Java正则表达式</p><p><a href="https://www.runoob.com/java/java-regular-expressions.html">https://www.runoob.com/java/java-regular-expressions.html</a></p><ul><li><p>简介</p><ul><li><p>正则表达式定义了字符串的模式。</p></li><li><p>正则表达式可以用来搜索、编辑或处理文本。</p></li><li><p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p></li></ul></li><li><p>java.util.regex 包主要包括以下三个类：</p><ul><li><p><strong>Pattern 类：</strong></p><p>pattern 对象是一个正则表达式的<strong>编译表示</strong>。Pattern 类<strong>没有公共构造方法</strong>。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</p></li><li><p><strong>Matcher 类：</strong></p><p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</p></li><li><p><strong>PatternSyntaxException：</strong></p><p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p></li></ul><p>实例</p><pre><code class="java">import java.util.regex.*; class RegexExample1&#123;   public static void main(String[] args)&#123;      String content = &quot;I am noob &quot; +        &quot;from runoob.com.&quot;;       String pattern = &quot;.*runoob.*&quot;;       boolean isMatch = Pattern.matches(pattern, content);      System.out.println(&quot;字符串中是否包含了 &#39;runoob&#39; 子字符串? &quot; + isMatch);//true   &#125;&#125;</code></pre></li></ul><h2 id="9-数列求和"><a href="#9-数列求和" class="headerlink" title="9. 数列求和"></a>9. 数列求和</h2><pre><code class="java">long num = 0;long sum = 0L;for (int i = 1; i &lt;= 10; i++) &#123;    num = num * 10L + 9L;    sum += num;&#125;System.out.print(sum);</code></pre><h2 id="10-统计输入正数个数"><a href="#10-统计输入正数个数" class="headerlink" title="10. 统计输入正数个数"></a>10. 统计输入正数个数</h2><pre><code class="java">int i = -1;int num;do &#123;    i++;    num = scanner.nextInt();&#125; while(num &gt; 0);System.out.print(i);scanner.close();</code></pre><h2 id="11-求最小公倍数"><a href="#11-求最小公倍数" class="headerlink" title="11. 求最小公倍数"></a>11. 求最小公倍数</h2><pre><code class="java">public static int getCM(int m, int n)&#123;    //write your code here......    int b = m &gt; n ? m : n;//大的那一个    int s = (b == m) ? n : m;//小的那一个    int result = b;    while (result%s != 0) &#123;        result += b;    &#125;    return result;&#125;</code></pre><h2 id="12-小球走过的路程计算"><a href="#12-小球走过的路程计算" class="headerlink" title="12. 小球走过的路程计算"></a>12. 小球走过的路程计算</h2><pre><code class="java">double total = 0;do &#123;    total += h;    h = h / 2.0f;    total += h;&#125; while (--n &gt; 0);total = total - h;//输出格式为：System.out.println(String.format(&quot;%.3f&quot;, h)+&quot; &quot;+String.format(&quot;%.3f&quot;, sum));System.out.println(String.format(&quot;%.3f&quot;, h)+&quot; &quot;+String.format(&quot;%.3f&quot;, total));</code></pre><h2 id="13-求平均数"><a href="#13-求平均数" class="headerlink" title="13. 求平均数"></a>13. 求平均数</h2><pre><code class="java">Long total = 0L;int num = 0;int nextInt = 0;while (scan.hasNextInt() &amp;&amp; (nextInt = scan.nextInt()) &gt;= 0) &#123;    total += nextInt;    num++;&#125;double avg = (double)total / num;System.out.println(String.format(&quot;%.2f&quot;, avg));</code></pre><h2 id="14-判断质数"><a href="#14-判断质数" class="headerlink" title="14. 判断质数"></a>14. 判断质数</h2><pre><code class="java">public Boolean isPrimeNumber(int number) &#123;    //write your code here......    int i = number / 2;    for (int j = i; j &gt; 1; j--) &#123;        if (number % j == 0) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><h2 id="15-计算整数位数"><a href="#15-计算整数位数" class="headerlink" title="15. 计算整数位数"></a>15. 计算整数位数</h2><pre><code class="java">if (num &lt;= 0) &#123;    System.out.print(num);&#125; else &#123;    int n = 0;    while (num &gt; 0) &#123;        n++;        num /= 10;    &#125;    System.out.print(n);&#125;</code></pre><h2 id="16-数组遍历"><a href="#16-数组遍历" class="headerlink" title="16. 数组遍历"></a>16. 数组遍历</h2><pre><code class="java">max = Integer.MIN_VALUE;min = Integer.MAX_VALUE;for (int n: ary) &#123;    max = n &gt; max ? n : max;    min = n &lt; min ? n : min;&#125;</code></pre><h2 id="17-数组倒转"><a href="#17-数组倒转" class="headerlink" title="17. 数组倒转"></a>17. 数组倒转</h2><pre><code class="java">int temp;for (int i = 0; i &lt; arr.length / 2; i++) &#123;    temp = arr[i];    arr[i] = arr[arr.length - i - 1];    arr[arr.length - i - 1] = temp;&#125;</code></pre><h2 id="18-二维数组求和"><a href="#18-二维数组求和" class="headerlink" title="18. 二维数组求和"></a>18. 二维数组求和</h2><pre><code class="java">for (int i = 0; i &lt; arr.length; i++) &#123;    int[] rowArr = arr[i];    for (int j = 0; j &lt; rowArr.length; j++) &#123;        sum += rowArr[j];    &#125;&#125;</code></pre><h2 id="19-修改Data类的定义"><a href="#19-修改Data类的定义" class="headerlink" title="19. 修改Data类的定义"></a>19. 修改Data类的定义</h2><pre><code class="java">class Data &#123;    private int x;    private int y;        public Data(int x, int y) &#123;        this.x = x;        this.y = y;    &#125;    public int getX() &#123;        return x;    &#125;    public int getY() &#123;        return y;    &#125;&#125;</code></pre><h2 id="20-验证年龄"><a href="#20-验证年龄" class="headerlink" title="20. 验证年龄"></a>20. 验证年龄</h2><pre><code class="java">class Person &#123;    private int age;    //write your code here......    public void setAge(int age) &#123;        if (age &lt; 0) &#123;            this.age = 0;         &#125; else if (age &gt; 200) &#123;            this.age = 200;        &#125; else &#123;            this.age = age;        &#125;            &#125;    public int getAge() &#123;        return age;    &#125;&#125;</code></pre><h2 id="21-补全构造方法"><a href="#21-补全构造方法" class="headerlink" title="21. 补全构造方法"></a>21. 补全构造方法</h2><pre><code class="java">super(x, y);this.z = z;</code></pre><h2 id="22-重写计算逻辑"><a href="#22-重写计算逻辑" class="headerlink" title="22. 重写计算逻辑"></a>22. 重写计算逻辑</h2><p>这里遇到了一点小插曲。因为题目中没有说要写子类构造方法，我也就没注意，结果编译时报错了。</p><pre><code>Main.java:10: error: constructor Sub in class Sub cannot be applied to given types;Sub sub = new Sub(x, y);required: no argumentsfound: int,int</code></pre><p>大致意思就是我没有提供Sub(int,int)这样的构造函数。我看了一下，基类有构造函数Base(int x, int y)，我突然回忆不起默认构造函数在父类有构造函数时是怎样的情况了。于是到网上搜了一下，发现很多讲默认构造函数的文章都是一笔带过，没办法直接看Java Se 8 Specification吧。规范中给出了这样的示例：</p><p>下面的声明：</p><pre><code class="java">public class Point &#123;    int x, y;&#125;</code></pre><p>与这个声明相同：</p><pre><code class="java">public class Point &#123;    int x, y;    public Point() &#123; super(); &#125;&#125;</code></pre><p>所以父类如果没有无参构造函数，子类就不能使用默认构造函数了。（看到这个示例的时候又觉得自己的记忆中就是这样的情况，但是有时候脑子就是这样，看到答案时会觉得简单）</p><p>补齐构造函数：</p><pre><code class="java">class Sub extends Base &#123;    public Sub(int x, int y) &#123;        super(x, y);    &#125;    //write your code here......    @Override    public void calculate() &#123;        System.out.println(getY() == 0 ? &quot;Error&quot; : getX() / getY());    &#125;&#125;</code></pre><h2 id="23-定义打印方法"><a href="#23-定义打印方法" class="headerlink" title="23. 定义打印方法"></a>23. 定义打印方法</h2><pre><code class="java">private static void print(Object obj) &#123;    System.out.print(obj.toString());&#125;</code></pre><h2 id="24-类型判断"><a href="#24-类型判断" class="headerlink" title="24. 类型判断"></a>24. 类型判断</h2><pre><code class="java">public static String getClassName(Base obj) &#123;    //write your code here......    if (obj instanceof Sub2) &#123;        return &quot;Sub2&quot;;    &#125; else if (obj instanceof Sub1) &#123;        return &quot;Sub1&quot;;    &#125; else &#123;        return &quot;Base&quot;;    &#125;&#125;</code></pre><h2 id="25-实现抽象方法"><a href="#25-实现抽象方法" class="headerlink" title="25. 实现抽象方法"></a>25. 实现抽象方法</h2><pre><code class="java">class Sub extends Base &#123;    //write your code here......    @Override    public int sum() &#123;        return getX() + getY();    &#125;    @Override     public int avg() &#123;        return sum() / 2;    &#125;&#125;</code></pre><h2 id="26-实现接口"><a href="#26-实现接口" class="headerlink" title="26. 实现接口"></a>26. 实现接口</h2><pre><code class="java">class ComparatorImpl implements Comparator &#123;    @Override    public int max(int x, int y) &#123;        return x &gt; y ? x : y;    &#125;&#125;</code></pre><p>这里我以为接口方法在实现时不能加@Override，结果是可以的。看来@Override不止可以用于重写父类的方法。</p><p>SE8官方文档中这样写到：</p><p><strong>If a method declaration is annotated with the annotation</strong> <code>@Override</code><strong>, but the method does not override or implement a method declared in a supertype, or is not override-equivalent to a</strong> <code>public</code> <strong>method of</strong> <code>Object</code><strong>, a compile-time error occurs.</strong></p><p>翻译：如果一个方法声明用@Override进行注解，但是方法没有重写或者<strong>实现</strong>声明在超类型中方法，或者对Object的公共方法来说不是override-equivalent的，那么就会产生一个编译时错误。</p><p>看到这里已经可以解决上面的问题了：@Override可以用于实现接口方法声明的方法。</p><p>但是新的疑问又产生了：So what is override-equivalent?</p><p>首先给出我的答案来源：<a href="https://stackoverflow.com/questions/16207386/what-is-override-equivalence-and-how-is-it-related-to-override">https://stackoverflow.com/questions/16207386/what-is-override-equivalence-and-how-is-it-related-to-override</a></p><p>但是我没看楼主的答案，而是根据楼主的提示——官方文档中有解释——找到了答案。</p><p>The signature of a method <code>m1</code> is a <em>subsignature</em> of the signature of a method <code>m2</code> if either:</p><ul><li><code>m2</code> has the same signature as <code>m1</code>, or</li><li>the signature of <code>m1</code> is the same as the erasure (<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6">§4.6</a>) of the signature of <code>m2</code>.</li></ul><p>Two method signatures <code>m1</code> and <code>m2</code> are <em>override-equivalent</em> iff either <code>m1</code> is a subsignature of <code>m2</code> or <code>m2</code> is a subsignature of <code>m1</code>.</p><p>大致意思是说：函数签名是override-equivalent的条件是m1是m2的子签名或者m2是m1的子签名。而如果方法m2的签名与方法m1的签名相同或者m1的签名与m2的签名的erasure相同，则可以说m1的子签名是m2的签名的子签名。</p><p>那什么又是erasure捏？（苦笑）</p><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6">https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.6</a> 内容实在是有点多，如果有时间我会斗胆翻译一下，感兴趣的可以去看看。</p><h2 id="27-重写父类方法"><a href="#27-重写父类方法" class="headerlink" title="27. 重写父类方法"></a>27. 重写父类方法</h2><pre><code class="java">class Sub extends Base &#123;    public Sub(int x, int y) &#123;        super(x, y);    &#125;    //write your code here......    @Override    public int getX() &#123;        return super.getX() * 10;    &#125;&#125;</code></pre><h2 id="28-创建单例对象"><a href="#28-创建单例对象" class="headerlink" title="28. 创建单例对象"></a>28. 创建单例对象</h2><pre><code class="java">public static Singleton getInstance() &#123;    if (instance == null) &#123;        instance = new Singleton();    &#125;    return instance;&#125;</code></pre><h2 id="29-动态字符串"><a href="#29-动态字符串" class="headerlink" title="29. 动态字符串"></a>29. 动态字符串</h2><pre><code class="java">int len = str.length();int remainder = len % 3;int commas = len / 3 - 1;if (remainder != 0) &#123;    commas++;&#125;StringBuilder newStr = new StringBuilder(commas + len);for (int i  = 0; i &lt; len; i++) &#123;    newStr.append(str.charAt(i));    if ((i+1) % 3 == remainder &amp;&amp; i != len - 1) &#123;        newStr.append(&quot;,&quot;);    &#125;&#125;System.out.print(newStr);</code></pre><h2 id="30-统计字符串中字母出现次数"><a href="#30-统计字符串中字母出现次数" class="headerlink" title="30. 统计字符串中字母出现次数"></a>30. 统计字符串中字母出现次数</h2><pre><code class="java">public static int check(String str, String word) &#123;    //write your code here......    int times = 0;    int from = -1;    while (true) &#123;        from = str.indexOf(word, from + 1);        if (from == -1) &#123;            break;        &#125;        times++;    &#125;    return times;&#125;</code></pre><h2 id="31-十进制数转二进制数"><a href="#31-十进制数转二进制数" class="headerlink" title="31. 十进制数转二进制数"></a>31. 十进制数转二进制数</h2><pre><code class="java">//write your code here......StringBuilder strNum = new StringBuilder();while (num &gt; 0) &#123;    strNum.insert(0, num % 2);    num /= 2;&#125;//这里题目的输入描述其实说了输入的是正整数，但是测试用例里有0System.out.println(strNum.length() &gt; 0 ? strNum : 0);</code></pre><h2 id="33-掷骰子"><a href="#33-掷骰子" class="headerlink" title="33. 掷骰子"></a>33. 掷骰子</h2><pre><code class="java">System.out.print(random.nextInt(6) + 1);</code></pre><h2 id="34-求绝对值，平方根，对数，正弦值"><a href="#34-求绝对值，平方根，对数，正弦值" class="headerlink" title="34. 求绝对值，平方根，对数，正弦值"></a>34. 求绝对值，平方根，对数，正弦值</h2><pre><code class="java">System.out.println(Math.abs(num));System.out.println(Math.sqrt(num));System.out.println(Math.log(num));System.out.println(Math.sin(num));</code></pre><h2 id="35-输出某一年的各个月份的天数"><a href="#35-输出某一年的各个月份的天数" class="headerlink" title="35. 输出某一年的各个月份的天数"></a>35. 输出某一年的各个月份的天数</h2><p>没怎么用过Calendar这个类，感觉自己写得太麻烦了。</p><pre><code class="java">import java.util.Calendar;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner console = new Scanner(System.in);        int year = console.nextInt();        //write your code here......        Calendar cal = Calendar.getInstance();        cal.set(year, 0, 1);//Calendar类月份从0开始计！即0表示1月份。        int month = 1;//用于记录当前的月份        int countDay = 0;//用于记录一个月的天数        while (month &lt;= 12) &#123;            cal.add(Calendar.DAY_OF_MONTH, 1);            countDay++;            while (cal.get(Calendar.DAY_OF_MONTH) != 1) &#123;                cal.add(Calendar.DAY_OF_MONTH, 1);                countDay++;            &#125;                                    System.out.println(year + &quot;年&quot; + month + &quot;月:&quot; + countDay + &quot;天&quot;);            countDay = 0;            month++;        &#125;    &#125;&#125;</code></pre><h2 id="36-日期换算"><a href="#36-日期换算" class="headerlink" title="36. 日期换算"></a>36. 日期换算</h2><pre><code class="java">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);Scanner in = new Scanner(System.in);String str1 = in.nextLine();//write your code here......String[] dateTimeStr = str1.split(&quot; &quot;);if (dateTimeStr.length &lt; 6) &#123;    System.out.print(&quot;您输入的数据不合理&quot;);    return;&#125;            int year = Integer.valueOf(dateTimeStr[0]);int month = Integer.valueOf(dateTimeStr[1]);int day = Integer.valueOf(dateTimeStr[2]);int hour = Integer.valueOf(dateTimeStr[3]);int minute = Integer.valueOf(dateTimeStr[4]);int second = Integer.valueOf(dateTimeStr[5]);     LocalDateTime dateTime = LocalDateTime.of(year, 1, 1, 0, 0, 0);dateTime = dateTime.plusMonths(month-1);dateTime = dateTime.plusDays(day-1);dateTime = dateTime.plusHours(hour);dateTime = dateTime.plusMinutes(minute);dateTime = dateTime.plusSeconds(second);System.out.println(&quot;北京时间为：&quot; + dateTime.format(dtf));dateTime = dateTime.minusHours(12);System.out.println(&quot;纽约时间为：&quot; + dateTime.format(dtf));</code></pre><h2 id="37-判断学生成绩"><a href="#37-判断学生成绩" class="headerlink" title="37. 判断学生成绩"></a>37. 判断学生成绩</h2><pre><code class="java">import java.util.*;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int score = scanner.nextInt();        //write your code here......        try &#123;            if (!(score &gt;= 0 &amp;&amp; score &lt;= 100)) &#123;                throw new ScoreException(&quot;分数不合法&quot;);            &#125;            System.out.println(score);        &#125; catch (ScoreException ex)&#123;            System.out.println(ex.getMessage());        &#125;    &#125;&#125;class ScoreException extends Exception &#123;    //write your code here......    public ScoreException(String message) &#123;        super(message);    &#125;&#125;</code></pre><h2 id="38-字符串去重"><a href="#38-字符串去重" class="headerlink" title="38. 字符串去重"></a>38. 字符串去重</h2><pre><code class="java">import java.util.HashSet;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String str = scanner.nextLine();        scanner.close();        HashSet&lt;Character&gt; hs = new HashSet&lt;&gt;();        //write your code here......        for (int i = 0; i &lt; str.length(); i++) &#123;            hs.add(str.charAt(i));        &#125;        for (char c:hs) &#123;            System.out.print(c);        &#125;    &#125;&#125;</code></pre><h2 id="39-集合遍历"><a href="#39-集合遍历" class="headerlink" title="39. 集合遍历"></a>39. 集合遍历</h2><pre><code class="java">import java.util.ArrayList;import java.util.Iterator;import java.util.List;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int num1 = scanner.nextInt();        int num2 = scanner.nextInt();        int num3 = scanner.nextInt();        int num4 = scanner.nextInt();        int num5 = scanner.nextInt();        scanner.close();        list.add(num1);        list.add(num2);        list.add(num3);        list.add(num4);        list.add(num5);        System.out.print(&quot;普通for循环:&quot;);        //write your code here......        for (int i = 0; i &lt; list.size(); i++) &#123;            System.out.print(list.get(i) + &quot; &quot;);        &#125;        System.out.println();        System.out.print(&quot;增强for循环:&quot;);        //write your code here......        for (int n: list) &#123;            System.out.print(n + &quot; &quot;);        &#125;        System.out.println();        System.out.print(&quot;迭代器遍历:&quot;);        //write your code here......        Iterator iter =  list.listIterator();        while (iter.hasNext()) &#123;            System.out.print(iter.next() + &quot; &quot;);        &#125;        System.out.println();    &#125;&#125;</code></pre><h2 id="40-排队系统"><a href="#40-排队系统" class="headerlink" title="40. 排队系统"></a>40. 排队系统</h2><pre><code class="java">//write your code here......deque.addFirst(vipGuest);</code></pre><h2 id="41-Head-and-Tail-of-the-Queue"><a href="#41-Head-and-Tail-of-the-Queue" class="headerlink" title="41. Head and Tail of the Queue"></a>41. Head and Tail of the Queue</h2><pre><code class="java">// write your code here......boolean turnToHead = true;while (!deque.isEmpty()) &#123;    if (turnToHead) &#123;        System.out.println(deque.removeFirst());    &#125; else &#123;        System.out.println(deque.removeLast());    &#125;    turnToHead = !turnToHead;&#125;</code></pre><h2 id="42-统计一句话中重复单词的个数"><a href="#42-统计一句话中重复单词的个数" class="headerlink" title="42. 统计一句话中重复单词的个数"></a>42. 统计一句话中重复单词的个数</h2><pre><code class="java">//write your code here......for (int i = 0; i &lt; line.length(); i++) &#123;    Character c = line.charAt(i);    if (Character.isAlphabetic(c)) &#123;        Integer originNum = map.get(c);        if (originNum == null) &#123;            map.put(c, 1);        &#125; else &#123;            map.put(c, originNum + 1);        &#125;    &#125;&#125;</code></pre><h2 id="43-map简单应用"><a href="#43-map简单应用" class="headerlink" title="43. map简单应用"></a>43. map简单应用</h2><pre><code class="java">//write your code here......Set&lt;Integer&gt; keySet = map.keySet();Iterator&lt;Integer&gt; iter = keySet.iterator();while (iter.hasNext()) &#123;    Integer key = iter.next();    System.out.println(key + &quot;:&quot; + map.get(key));&#125;System.out.println();map.put(5, name);map.remove(4);map.put(3, &quot;Tommy&quot;);iter = keySet.iterator();while (iter.hasNext()) &#123;    Integer key = iter.next();    System.out.println(key + &quot;:&quot; + map.get(key));&#125;</code></pre><h2 id="44-集合排序"><a href="#44-集合排序" class="headerlink" title="44. 集合排序"></a>44. 集合排序</h2><pre><code class="java">import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        //其余代码省略        //write your code here......        Collections.sort(customers);        System.out.println(customers);    &#125;&#125;class Customer implements Comparable&lt;Customer&gt;&#123;    //其余代码省略    //write your code here......    @Override    public int compareTo(Customer other) &#123;        return other.consumption - consumption;    &#125;&#125;</code></pre><h2 id="45-判断各类型字符个数"><a href="#45-判断各类型字符个数" class="headerlink" title="45. 判断各类型字符个数"></a>45. 判断各类型字符个数</h2><pre><code class="java">//write your code here......for (int i = 0; i &lt; str.length(); i++) &#123;    if (str.charAt(i) == &#39; &#39;) &#123;        space++;    &#125; else if (Character.isAlphabetic(str.charAt(i))) &#123;        words++;    &#125; else if (Character.isDigit(str.charAt(i))) &#123;        numbers++;    &#125; else &#123;        other++;    &#125;&#125;</code></pre><h2 id="46-编写个人所得税计算程序"><a href="#46-编写个人所得税计算程序" class="headerlink" title="46. 编写个人所得税计算程序"></a>46. 编写个人所得税计算程序</h2><pre><code class="java">import java.util.*;public class Main &#123;    //税率    private static final double[] taxRates = &#123;0.03, 0.1, 0.2, 0.25, 0.3, 0.35, 0.45&#125;;    //速算扣除数    private static final double[] shouldMinus = &#123;0.0, 105.0, 555.0, 1005.0, 2755.0, 5505.0, 13505.0&#125;;    public static void main(String[] args) &#123;        List&lt;Employee&gt; employees = new ArrayList&lt;&gt;();        //write your code here......        //应纳税额 =（工资薪金所得－扣除数）×适用税率－速算扣除数        //扣除数为3500元        //全月应纳税所得额=工资薪金所得－扣除数。        employees.add(new Employee(&quot;小明&quot;, 2500));        employees.add(new Employee(&quot;小军&quot;, 8000));        employees.add(new Employee(&quot;小红&quot;, 100000));        for (Employee emp : employees) &#123;            System.out.println(emp.getName() + &quot;应该缴纳的个人所得税是：&quot; + getTax(emp));        &#125;    &#125;    /**     * 自定义方法，输入一个雇员，返回雇员所得税。     */    public static double getTax(Employee emp) &#123;        double salary = emp.getSalary();        if (Double.compare(salary, 3500) &lt; 0) &#123;            return 0.0;        &#125;                double monthIncome = salary - 3500.0;//全月应纳税所得额        if (Double.compare(monthIncome, 1500.0) &lt;= 0) &#123;            return monthIncome * taxRates[0] - shouldMinus[0];        &#125; else if (Double.compare(monthIncome, 4500.0) &lt;= 0) &#123;            return monthIncome * taxRates[1] - shouldMinus[1];        &#125; else if (Double.compare(monthIncome, 9000.0) &lt;= 0) &#123;            return monthIncome * taxRates[2] - shouldMinus[2];        &#125; else if (Double.compare(monthIncome, 35000.0) &lt;= 0) &#123;            return monthIncome * taxRates[3] - shouldMinus[3];        &#125; else if (Double.compare(monthIncome, 55000.0) &lt;= 0) &#123;            return monthIncome * taxRates[4] - shouldMinus[4];        &#125; else if (Double.compare(monthIncome, 80000.0) &lt;= 0) &#123;            return monthIncome * taxRates[5] - shouldMinus[5];        &#125; else&#123;            return monthIncome * taxRates[6] - shouldMinus[6];        &#125;    &#125;&#125;class Employee&#123;    private String name;    private double salary;    public Employee(String name, double salary) &#123;        this.name = name;        this.salary = salary;    &#125;    public String getName() &#123;        return name;    &#125;    public double getSalary() &#123;        return salary;    &#125;&#125;</code></pre><h2 id="47-记录点赞用户"><a href="#47-记录点赞用户" class="headerlink" title="47. 记录点赞用户"></a>47. 记录点赞用户</h2><pre><code class="java">class LikeRecorderImpl implements LikeRecorder &#123;    // write your code here......    private static final HashSet&lt;String&gt; likeNames = new HashSet&lt;&gt;();    @Override    public void like(String username) &#123;        if (likeNames.contains(username)) &#123;            likeNames.remove(username);            return;        &#125;        likeNames.add(username);    &#125;    @Override    public String[] getLikeUsers() &#123;        String[] result = new String[likeNames.size()];        return likeNames.toArray(result);    &#125;&#125;</code></pre><h2 id="48-回文数判断"><a href="#48-回文数判断" class="headerlink" title="48. 回文数判断"></a>48. 回文数判断</h2><pre><code class="java">public Boolean palindromeNumber(int number) &#123;    //write your code here......    String numberStr = &quot;&quot; + number;    for (int i = 0; i &lt; numberStr.length() / 2; i++) &#123;        if (numberStr.charAt(i) != numberStr.charAt(numberStr.length() - i - 1)) &#123;            return false;        &#125;    &#125;    return true;&#125;</code></pre><h2 id="49-判断素数个数"><a href="#49-判断素数个数" class="headerlink" title="49. 判断素数个数"></a>49. 判断素数个数</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int start = scanner.nextInt();        int end = scanner.nextInt();        method(start,end);    &#125;    public static void method(int start, int end) &#123;        int count=0;        //write your code here......        start = start &gt; end ? end + 0 * (end = start) : start;//如果start &gt; end交换start和end的值        for (int i = start; i &lt;= end; i++) &#123;            if (isPrimeGreaterThan2(i)) &#123;                count++;            &#125;        &#125;        System.out.println(start+&quot;到&quot;+end+&quot;之间有&quot;+count+&quot;个大于2的素数&quot;);    &#125;    public static boolean isPrimeGreaterThan2(int n) &#123;        if (n &lt;= 2)            return false;        for (int i = 2; i &lt;= n / 2; i++) &#123;            if (n % i == 0)                return false;        &#125;        return true;    &#125;&#125;</code></pre><h2 id="50-根据周长求面积"><a href="#50-根据周长求面积" class="headerlink" title="50. 根据周长求面积"></a>50. 根据周长求面积</h2><pre><code class="java">import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextDouble()) &#123;            double s = scanner.nextDouble();            // Circle和Square是需要你定义的类            System.out.println(String.format(&quot;%.3f&quot;,new Circle(s).getArea()));            System.out.println(String.format(&quot;%.3f&quot;, new Square(s).getArea()));        &#125;    &#125;&#125;class Shape &#123;    private double s; // 周长    public Shape(double s) &#123;        this.s = s;    &#125;    public double getS() &#123;        return s;    &#125;&#125;interface Area &#123;    double getArea(); // 面积&#125;// 圆形class Circle extends Shape implements Area &#123;    //write your code here......    public Circle(double s) &#123;        super(s);    &#125;    @Override    public double getArea() &#123;        double radius = getS() / (2 * Math.PI);        return radius * radius * Math.PI;    &#125;&#125;// 方形class Square extends Shape implements Area &#123;    //write your code here......    public Square(double s) &#123;        super(s);    &#125;    @Override    public double getArea() &#123;        double radius = getS() / 4;        return radius * radius;    &#125;&#125;</code></pre><h2 id="51-冒泡排序"><a href="#51-冒泡排序" class="headerlink" title="51. 冒泡排序"></a>51. 冒泡排序</h2><pre><code class="java">//write your code here......int temp;for (int i = arr.length - 1; i &gt;= 0; i--) &#123;    for (int j  = 0; j &lt; i; j++) &#123;        if (arr[j] &gt; arr[j+1]) &#123;            temp = arr[j];            arr[j] = arr[j+1];            arr[j+1] = temp;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
